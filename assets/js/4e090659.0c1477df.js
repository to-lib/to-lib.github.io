"use strict";(globalThis.webpackChunkto_lib_github_io=globalThis.webpackChunkto_lib_github_io||[]).push([[22147],{28198:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>s,default:()=>c,frontMatter:()=>o,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"c/data-structures","title":"\u6570\u636e\u7ed3\u6784\u5b9e\u73b0","description":"\u4f7f\u7528 C \u8bed\u8a00\u5b9e\u73b0\u5e38\u7528\u6570\u636e\u7ed3\u6784\u3002","source":"@site/docs/c/data-structures.md","sourceDirName":"c","slug":"/c/data-structures","permalink":"/docs/c/data-structures","draft":false,"unlisted":false,"editUrl":"https://github.com/to-lib/to-lib.github.io/tree/main/docs/c/data-structures.md","tags":[],"version":"current","sidebarPosition":12,"frontMatter":{"sidebar_position":12,"title":"\u6570\u636e\u7ed3\u6784\u5b9e\u73b0"},"sidebar":"c","previous":{"title":"\u590d\u6570\u4e0e\u9ad8\u7ea7\u6570\u5b66","permalink":"/docs/c/complex-math"},"next":{"title":"\u591a\u6587\u4ef6\u7f16\u7a0b","permalink":"/docs/c/multi-file"}}');var i=t(22714),d=t(48885);const o={sidebar_position:12,title:"\u6570\u636e\u7ed3\u6784\u5b9e\u73b0"},s="\u6570\u636e\u7ed3\u6784\u5b9e\u73b0",a={},u=[{value:"\u94fe\u8868",id:"\u94fe\u8868",level:2},{value:"\u5355\u94fe\u8868",id:"\u5355\u94fe\u8868",level:3},{value:"\u6808",id:"\u6808",level:2},{value:"\u961f\u5217",id:"\u961f\u5217",level:2},{value:"\u4e8c\u53c9\u6811",id:"\u4e8c\u53c9\u6811",level:2},{value:"\u54c8\u5e0c\u8868",id:"\u54c8\u5e0c\u8868",level:2}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,d.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"\u6570\u636e\u7ed3\u6784\u5b9e\u73b0",children:"\u6570\u636e\u7ed3\u6784\u5b9e\u73b0"})}),"\n",(0,i.jsx)(e.p,{children:"\u4f7f\u7528 C \u8bed\u8a00\u5b9e\u73b0\u5e38\u7528\u6570\u636e\u7ed3\u6784\u3002"}),"\n",(0,i.jsx)(e.h2,{id:"\u94fe\u8868",children:"\u94fe\u8868"}),"\n",(0,i.jsx)(e.h3,{id:"\u5355\u94fe\u8868",children:"\u5355\u94fe\u8868"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int data;\n    struct Node *next;\n} Node;\n\ntypedef struct {\n    Node *head;\n    int size;\n} LinkedList;\n\nLinkedList* createList(void) {\n    LinkedList *list = malloc(sizeof(LinkedList));\n    list->head = NULL;\n    list->size = 0;\n    return list;\n}\n\nvoid append(LinkedList *list, int data) {\n    Node *node = malloc(sizeof(Node));\n    node->data = data;\n    node->next = NULL;\n\n    if (list->head == NULL) {\n        list->head = node;\n    } else {\n        Node *curr = list->head;\n        while (curr->next) curr = curr->next;\n        curr->next = node;\n    }\n    list->size++;\n}\n\nvoid prepend(LinkedList *list, int data) {\n    Node *node = malloc(sizeof(Node));\n    node->data = data;\n    node->next = list->head;\n    list->head = node;\n    list->size++;\n}\n\nvoid removeAt(LinkedList *list, int index) {\n    if (index < 0 || index >= list->size) return;\n\n    Node *temp;\n    if (index == 0) {\n        temp = list->head;\n        list->head = list->head->next;\n    } else {\n        Node *curr = list->head;\n        for (int i = 0; i < index - 1; i++) {\n            curr = curr->next;\n        }\n        temp = curr->next;\n        curr->next = temp->next;\n    }\n    free(temp);\n    list->size--;\n}\n\nvoid printList(LinkedList *list) {\n    Node *curr = list->head;\n    while (curr) {\n        printf("%d -> ", curr->data);\n        curr = curr->next;\n    }\n    printf("NULL\\n");\n}\n\nvoid freeList(LinkedList *list) {\n    Node *curr = list->head;\n    while (curr) {\n        Node *temp = curr;\n        curr = curr->next;\n        free(temp);\n    }\n    free(list);\n}\n\nint main(void) {\n    LinkedList *list = createList();\n\n    append(list, 10);\n    append(list, 20);\n    append(list, 30);\n    prepend(list, 5);\n\n    printList(list);  // 5 -> 10 -> 20 -> 30 -> NULL\n\n    removeAt(list, 1);\n    printList(list);  // 5 -> 20 -> 30 -> NULL\n\n    freeList(list);\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"\u6808",children:"\u6808"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int data[MAX_SIZE];\n    int top;\n} Stack;\n\nStack* createStack(void) {\n    Stack *s = malloc(sizeof(Stack));\n    s->top = -1;\n    return s;\n}\n\nbool isEmpty(Stack *s) { return s->top == -1; }\nbool isFull(Stack *s) { return s->top == MAX_SIZE - 1; }\n\nvoid push(Stack *s, int value) {\n    if (!isFull(s)) {\n        s->data[++s->top] = value;\n    }\n}\n\nint pop(Stack *s) {\n    if (!isEmpty(s)) {\n        return s->data[s->top--];\n    }\n    return -1;\n}\n\nint peek(Stack *s) {\n    if (!isEmpty(s)) {\n        return s->data[s->top];\n    }\n    return -1;\n}\n\nint main(void) {\n    Stack *s = createStack();\n\n    push(s, 10);\n    push(s, 20);\n    push(s, 30);\n\n    printf("\u6808\u9876: %d\\n", peek(s));\n    printf("\u5f39\u51fa: %d\\n", pop(s));\n    printf("\u5f39\u51fa: %d\\n", pop(s));\n\n    free(s);\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"\u961f\u5217",children:"\u961f\u5217"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int data[MAX_SIZE];\n    int front, rear;\n} Queue;\n\nQueue* createQueue(void) {\n    Queue *q = malloc(sizeof(Queue));\n    q->front = 0;\n    q->rear = -1;\n    return q;\n}\n\nbool isEmpty(Queue *q) { return q->rear < q->front; }\nbool isFull(Queue *q) { return q->rear >= MAX_SIZE - 1; }\n\nvoid enqueue(Queue *q, int value) {\n    if (!isFull(q)) {\n        q->data[++q->rear] = value;\n    }\n}\n\nint dequeue(Queue *q) {\n    if (!isEmpty(q)) {\n        return q->data[q->front++];\n    }\n    return -1;\n}\n\nint main(void) {\n    Queue *q = createQueue();\n\n    enqueue(q, 10);\n    enqueue(q, 20);\n    enqueue(q, 30);\n\n    printf("\u51fa\u961f: %d\\n", dequeue(q));\n    printf("\u51fa\u961f: %d\\n", dequeue(q));\n\n    free(q);\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"\u4e8c\u53c9\u6811",children:"\u4e8c\u53c9\u6811"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct TreeNode {\n    int data;\n    struct TreeNode *left, *right;\n} TreeNode;\n\nTreeNode* createNode(int data) {\n    TreeNode *node = malloc(sizeof(TreeNode));\n    node->data = data;\n    node->left = node->right = NULL;\n    return node;\n}\n\n// \u524d\u5e8f\u904d\u5386\nvoid preorder(TreeNode *root) {\n    if (root == NULL) return;\n    printf("%d ", root->data);\n    preorder(root->left);\n    preorder(root->right);\n}\n\n// \u4e2d\u5e8f\u904d\u5386\nvoid inorder(TreeNode *root) {\n    if (root == NULL) return;\n    inorder(root->left);\n    printf("%d ", root->data);\n    inorder(root->right);\n}\n\n// \u540e\u5e8f\u904d\u5386\nvoid postorder(TreeNode *root) {\n    if (root == NULL) return;\n    postorder(root->left);\n    postorder(root->right);\n    printf("%d ", root->data);\n}\n\nvoid freeTree(TreeNode *root) {\n    if (root == NULL) return;\n    freeTree(root->left);\n    freeTree(root->right);\n    free(root);\n}\n\nint main(void) {\n    TreeNode *root = createNode(1);\n    root->left = createNode(2);\n    root->right = createNode(3);\n    root->left->left = createNode(4);\n    root->left->right = createNode(5);\n\n    printf("\u524d\u5e8f: "); preorder(root); printf("\\n");\n    printf("\u4e2d\u5e8f: "); inorder(root); printf("\\n");\n    printf("\u540e\u5e8f: "); postorder(root); printf("\\n");\n\n    freeTree(root);\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.h2,{id:"\u54c8\u5e0c\u8868",children:"\u54c8\u5e0c\u8868"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define SIZE 100\n\ntypedef struct Entry {\n    char *key;\n    int value;\n    struct Entry *next;\n} Entry;\n\ntypedef struct {\n    Entry *buckets[SIZE];\n} HashMap;\n\nunsigned int hash(const char *key) {\n    unsigned int h = 0;\n    while (*key) h = h * 31 + *key++;\n    return h % SIZE;\n}\n\nHashMap* createMap(void) {\n    HashMap *map = calloc(1, sizeof(HashMap));\n    return map;\n}\n\nvoid put(HashMap *map, const char *key, int value) {\n    unsigned int idx = hash(key);\n    Entry *e = map->buckets[idx];\n\n    while (e) {\n        if (strcmp(e->key, key) == 0) {\n            e->value = value;\n            return;\n        }\n        e = e->next;\n    }\n\n    Entry *new = malloc(sizeof(Entry));\n    new->key = strdup(key);\n    new->value = value;\n    new->next = map->buckets[idx];\n    map->buckets[idx] = new;\n}\n\nint get(HashMap *map, const char *key, int *found) {\n    unsigned int idx = hash(key);\n    Entry *e = map->buckets[idx];\n\n    while (e) {\n        if (strcmp(e->key, key) == 0) {\n            if (found) *found = 1;\n            return e->value;\n        }\n        e = e->next;\n    }\n    if (found) *found = 0;\n    return 0;\n}\n\nint main(void) {\n    HashMap *map = createMap();\n\n    put(map, "apple", 100);\n    put(map, "banana", 200);\n\n    int found;\n    printf("apple: %d\\n", get(map, "apple", &found));\n    printf("banana: %d\\n", get(map, "banana", &found));\n\n    return 0;\n}\n'})}),"\n",(0,i.jsx)(e.p,{children:"\u638c\u63e1\u6570\u636e\u7ed3\u6784\u540e\uff0c\u5c31\u53ef\u4ee5\u7ee7\u7eed\u5b66\u4e60\u9879\u76ee\u5b9e\u6218\u4e86\uff01"})]})}function c(n={}){const{wrapper:e}={...(0,d.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(l,{...n})}):l(n)}},48885:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>s});var r=t(99378);const i={},d=r.createContext(i);function o(n){const e=r.useContext(d);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),r.createElement(d.Provider,{value:e},n.children)}}}]);