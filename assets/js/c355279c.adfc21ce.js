"use strict";(globalThis.webpackChunkto_lib_github_io=globalThis.webpackChunkto_lib_github_io||[]).push([[5774],{18292:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>_,frontMatter:()=>i,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"c/network-programming","title":"\u7f51\u7edc\u7f16\u7a0b","description":"\u4f7f\u7528 Socket API \u8fdb\u884c\u7f51\u7edc\u901a\u4fe1\u3002","source":"@site/docs/c/network-programming.md","sourceDirName":"c","slug":"/c/network-programming","permalink":"/docs/c/network-programming","draft":false,"unlisted":false,"editUrl":"https://github.com/to-lib/to-lib.github.io/tree/main/docs/c/network-programming.md","tags":[],"version":"current","sidebarPosition":19,"frontMatter":{"sidebar_position":19,"title":"\u7f51\u7edc\u7f16\u7a0b"},"sidebar":"c","previous":{"title":"\u5d4c\u5165\u5f0f\u7f16\u7a0b","permalink":"/docs/c/embedded"},"next":{"title":"\u591a\u7ebf\u7a0b\u7f16\u7a0b","permalink":"/docs/c/multithreading"}}');var d=r(22714),t=r(48885);const i={sidebar_position:19,title:"\u7f51\u7edc\u7f16\u7a0b"},c="C \u8bed\u8a00\u7f51\u7edc\u7f16\u7a0b",o={},a=[{value:"Socket \u57fa\u7840",id:"socket-\u57fa\u7840",level:2},{value:"\u57fa\u672c\u6982\u5ff5",id:"\u57fa\u672c\u6982\u5ff5",level:3},{value:"TCP \u670d\u52a1\u5668",id:"tcp-\u670d\u52a1\u5668",level:2},{value:"TCP \u5ba2\u6237\u7aef",id:"tcp-\u5ba2\u6237\u7aef",level:2},{value:"UDP \u901a\u4fe1",id:"udp-\u901a\u4fe1",level:2},{value:"UDP \u670d\u52a1\u5668",id:"udp-\u670d\u52a1\u5668",level:3},{value:"UDP \u5ba2\u6237\u7aef",id:"udp-\u5ba2\u6237\u7aef",level:3},{value:"\u591a\u5ba2\u6237\u7aef\u5904\u7406",id:"\u591a\u5ba2\u6237\u7aef\u5904\u7406",level:2},{value:"select \u591a\u8def\u590d\u7528",id:"select-\u591a\u8def\u590d\u7528",level:3},{value:"\u7f16\u8bd1",id:"\u7f16\u8bd1",level:2}];function l(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,t.R)(),...n.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(e.header,{children:(0,d.jsx)(e.h1,{id:"c-\u8bed\u8a00\u7f51\u7edc\u7f16\u7a0b",children:"C \u8bed\u8a00\u7f51\u7edc\u7f16\u7a0b"})}),"\n",(0,d.jsx)(e.p,{children:"\u4f7f\u7528 Socket API \u8fdb\u884c\u7f51\u7edc\u901a\u4fe1\u3002"}),"\n",(0,d.jsx)(e.h2,{id:"socket-\u57fa\u7840",children:"Socket \u57fa\u7840"}),"\n",(0,d.jsx)(e.h3,{id:"\u57fa\u672c\u6982\u5ff5",children:"\u57fa\u672c\u6982\u5ff5"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'// Socket \u5730\u5740\u7ed3\u6784\nstruct sockaddr_in {\n    sa_family_t    sin_family;  // AF_INET\n    in_port_t      sin_port;    // \u7aef\u53e3\u53f7 (\u7f51\u7edc\u5b57\u8282\u5e8f)\n    struct in_addr sin_addr;    // IP \u5730\u5740\n};\n\n// \u5b57\u8282\u5e8f\u8f6c\u6362\nhtons(port)    // \u4e3b\u673a\u5e8f -> \u7f51\u7edc\u5e8f (16\u4f4d)\nhtonl(addr)    // \u4e3b\u673a\u5e8f -> \u7f51\u7edc\u5e8f (32\u4f4d)\nntohs(port)    // \u7f51\u7edc\u5e8f -> \u4e3b\u673a\u5e8f (16\u4f4d)\nntohl(addr)    // \u7f51\u7edc\u5e8f -> \u4e3b\u673a\u5e8f (32\u4f4d)\n\n// IP \u5730\u5740\u8f6c\u6362\ninet_pton(AF_INET, "192.168.1.1", &addr);  // \u5b57\u7b26\u4e32 -> \u4e8c\u8fdb\u5236\ninet_ntop(AF_INET, &addr, buf, sizeof(buf)); // \u4e8c\u8fdb\u5236 -> \u5b57\u7b26\u4e32\n'})}),"\n",(0,d.jsx)(e.h2,{id:"tcp-\u670d\u52a1\u5668",children:"TCP \u670d\u52a1\u5668"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\nint main(void) {\n    int server_fd, client_fd;\n    struct sockaddr_in address;\n    socklen_t addrlen = sizeof(address);\n    char buffer[BUFFER_SIZE] = {0};\n\n    // 1. \u521b\u5efa socket\n    server_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_fd < 0) {\n        perror("socket");\n        exit(1);\n    }\n\n    // \u8bbe\u7f6e\u5730\u5740\u91cd\u7528\n    int opt = 1;\n    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));\n\n    // 2. \u7ed1\u5b9a\u5730\u5740\n    address.sin_family = AF_INET;\n    address.sin_addr.s_addr = INADDR_ANY;\n    address.sin_port = htons(PORT);\n\n    if (bind(server_fd, (struct sockaddr*)&address, sizeof(address)) < 0) {\n        perror("bind");\n        exit(1);\n    }\n\n    // 3. \u76d1\u542c\n    if (listen(server_fd, 5) < 0) {\n        perror("listen");\n        exit(1);\n    }\n\n    printf("\u670d\u52a1\u5668\u542f\u52a8\uff0c\u76d1\u542c\u7aef\u53e3 %d...\\n", PORT);\n\n    while (1) {\n        // 4. \u63a5\u53d7\u8fde\u63a5\n        client_fd = accept(server_fd, (struct sockaddr*)&address, &addrlen);\n        if (client_fd < 0) {\n            perror("accept");\n            continue;\n        }\n\n        printf("\u5ba2\u6237\u7aef\u8fde\u63a5: %s:%d\\n",\n               inet_ntoa(address.sin_addr), ntohs(address.sin_port));\n\n        // 5. \u63a5\u6536\u548c\u53d1\u9001\u6570\u636e\n        ssize_t bytes = read(client_fd, buffer, BUFFER_SIZE - 1);\n        if (bytes > 0) {\n            buffer[bytes] = \'\\0\';\n            printf("\u6536\u5230: %s\\n", buffer);\n\n            const char *response = "HTTP/1.1 200 OK\\r\\n\\r\\nHello from C Server!";\n            write(client_fd, response, strlen(response));\n        }\n\n        close(client_fd);\n    }\n\n    close(server_fd);\n    return 0;\n}\n'})}),"\n",(0,d.jsx)(e.h2,{id:"tcp-\u5ba2\u6237\u7aef",children:"TCP \u5ba2\u6237\u7aef"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\nint main(void) {\n    int sock;\n    struct sockaddr_in server_addr;\n    char buffer[BUFFER_SIZE] = {0};\n\n    // 1. \u521b\u5efa socket\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        perror("socket");\n        exit(1);\n    }\n\n    // 2. \u8bbe\u7f6e\u670d\u52a1\u5668\u5730\u5740\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(PORT);\n    inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);\n\n    // 3. \u8fde\u63a5\u670d\u52a1\u5668\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        perror("connect");\n        exit(1);\n    }\n\n    printf("\u5df2\u8fde\u63a5\u5230\u670d\u52a1\u5668\\n");\n\n    // 4. \u53d1\u9001\u6570\u636e\n    const char *message = "GET / HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n";\n    write(sock, message, strlen(message));\n\n    // 5. \u63a5\u6536\u54cd\u5e94\n    ssize_t bytes = read(sock, buffer, BUFFER_SIZE - 1);\n    if (bytes > 0) {\n        buffer[bytes] = \'\\0\';\n        printf("\u54cd\u5e94:\\n%s\\n", buffer);\n    }\n\n    close(sock);\n    return 0;\n}\n'})}),"\n",(0,d.jsx)(e.h2,{id:"udp-\u901a\u4fe1",children:"UDP \u901a\u4fe1"}),"\n",(0,d.jsx)(e.h3,{id:"udp-\u670d\u52a1\u5668",children:"UDP \u670d\u52a1\u5668"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\nint main(void) {\n    int sock;\n    struct sockaddr_in server_addr, client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    char buffer[BUFFER_SIZE];\n\n    sock = socket(AF_INET, SOCK_DGRAM, 0);\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(PORT);\n\n    bind(sock, (struct sockaddr*)&server_addr, sizeof(server_addr));\n\n    printf("UDP \u670d\u52a1\u5668\u542f\u52a8...\\n");\n\n    while (1) {\n        ssize_t bytes = recvfrom(sock, buffer, BUFFER_SIZE - 1, 0,\n                                  (struct sockaddr*)&client_addr, &client_len);\n        if (bytes > 0) {\n            buffer[bytes] = \'\\0\';\n            printf("\u6536\u5230: %s\\n", buffer);\n\n            // \u56de\u590d\n            sendto(sock, "OK", 2, 0,\n                   (struct sockaddr*)&client_addr, client_len);\n        }\n    }\n\n    return 0;\n}\n'})}),"\n",(0,d.jsx)(e.h3,{id:"udp-\u5ba2\u6237\u7aef",children:"UDP \u5ba2\u6237\u7aef"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\nint main(void) {\n    int sock;\n    struct sockaddr_in server_addr;\n    socklen_t addr_len = sizeof(server_addr);\n    char buffer[BUFFER_SIZE];\n\n    sock = socket(AF_INET, SOCK_DGRAM, 0);\n\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(PORT);\n    inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);\n\n    // \u53d1\u9001\n    const char *msg = "Hello UDP!";\n    sendto(sock, msg, strlen(msg), 0,\n           (struct sockaddr*)&server_addr, sizeof(server_addr));\n\n    // \u63a5\u6536\n    ssize_t bytes = recvfrom(sock, buffer, BUFFER_SIZE - 1, 0,\n                              (struct sockaddr*)&server_addr, &addr_len);\n    if (bytes > 0) {\n        buffer[bytes] = \'\\0\';\n        printf("\u54cd\u5e94: %s\\n", buffer);\n    }\n\n    close(sock);\n    return 0;\n}\n'})}),"\n",(0,d.jsx)(e.h2,{id:"\u591a\u5ba2\u6237\u7aef\u5904\u7406",children:"\u591a\u5ba2\u6237\u7aef\u5904\u7406"}),"\n",(0,d.jsx)(e.h3,{id:"select-\u591a\u8def\u590d\u7528",children:"select \u591a\u8def\u590d\u7528"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"#include <sys/select.h>\n\nvoid server_with_select(int server_fd) {\n    fd_set readfds, master;\n    int max_fd = server_fd;\n    int client_fds[FD_SETSIZE] = {0};\n\n    FD_ZERO(&master);\n    FD_SET(server_fd, &master);\n\n    while (1) {\n        readfds = master;\n\n        if (select(max_fd + 1, &readfds, NULL, NULL, NULL) < 0) {\n            continue;\n        }\n\n        // \u68c0\u67e5\u65b0\u8fde\u63a5\n        if (FD_ISSET(server_fd, &readfds)) {\n            int client = accept(server_fd, NULL, NULL);\n            FD_SET(client, &master);\n            if (client > max_fd) max_fd = client;\n        }\n\n        // \u68c0\u67e5\u5ba2\u6237\u7aef\u6570\u636e\n        for (int fd = 0; fd <= max_fd; fd++) {\n            if (fd != server_fd && FD_ISSET(fd, &readfds)) {\n                char buf[1024];\n                ssize_t n = read(fd, buf, sizeof(buf));\n                if (n <= 0) {\n                    close(fd);\n                    FD_CLR(fd, &master);\n                } else {\n                    // \u5904\u7406\u6570\u636e\n                    write(fd, buf, n);  // echo\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,d.jsx)(e.h2,{id:"\u7f16\u8bd1",children:"\u7f16\u8bd1"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-bash",children:"# Linux\ngcc server.c -o server\ngcc client.c -o client\n\n# macOS \u76f8\u540c\n\n# \u8fd0\u884c\n./server &\n./client\n"})}),"\n",(0,d.jsx)(e.p,{children:"\u638c\u63e1 Socket \u7f16\u7a0b\uff0c\u6784\u5efa\u7f51\u7edc\u5e94\u7528\uff01"})]})}function _(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(l,{...n})}):l(n)}},48885:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>c});var s=r(99378);const d={},t=s.createContext(d);function i(n){const e=s.useContext(t);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(d):n.components||d:i(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);