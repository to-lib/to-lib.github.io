"use strict";(globalThis.webpackChunkto_lib_github_io=globalThis.webpackChunkto_lib_github_io||[]).push([[86946],{48885:(n,o,e)=>{e.d(o,{R:()=>c,x:()=>s});var t=e(99378);const r={},i=t.createContext(r);function c(n){const o=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(o):{...o,...n}},[o,n])}function s(n){let o;return o=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),t.createElement(i.Provider,{value:o},n.children)}},81692:(n,o,e)=>{e.r(o),e.d(o,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"c/practical-projects","title":"\u9879\u76ee\u5b9e\u6218","description":"\u901a\u8fc7\u5b9e\u9645\u9879\u76ee\u5de9\u56fa C \u8bed\u8a00\u77e5\u8bc6\u3002","source":"@site/docs/c/practical-projects.md","sourceDirName":"c","slug":"/c/practical-projects","permalink":"/docs/c/practical-projects","draft":false,"unlisted":false,"editUrl":"https://github.com/to-lib/to-lib.github.io/tree/main/docs/c/practical-projects.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"sidebar_position":15,"title":"\u9879\u76ee\u5b9e\u6218"},"sidebar":"c","previous":{"title":"\u6784\u5efa\u7cfb\u7edf (Makefile & CMake)","permalink":"/docs/c/build-systems"},"next":{"title":"\u6027\u80fd\u4f18\u5316","permalink":"/docs/c/performance"}}');var r=e(22714),i=e(48885);const c={sidebar_position:15,title:"\u9879\u76ee\u5b9e\u6218"},s="\u9879\u76ee\u5b9e\u6218",l={},d=[{value:"\u9879\u76ee 1\uff1a\u547d\u4ee4\u884c\u8ba1\u7b97\u5668",id:"\u9879\u76ee-1\u547d\u4ee4\u884c\u8ba1\u7b97\u5668",level:2},{value:"\u9879\u76ee 2\uff1a\u901a\u8baf\u5f55\u7ba1\u7406",id:"\u9879\u76ee-2\u901a\u8baf\u5f55\u7ba1\u7406",level:2},{value:"\u9879\u76ee 3\uff1a\u7b80\u6613\u6587\u4ef6\u52a0\u5bc6",id:"\u9879\u76ee-3\u7b80\u6613\u6587\u4ef6\u52a0\u5bc6",level:2},{value:"\u9879\u76ee 4\uff1a\u8bcd\u9891\u7edf\u8ba1",id:"\u9879\u76ee-4\u8bcd\u9891\u7edf\u8ba1",level:2},{value:"\u9879\u76ee 5\uff1a\u7b80\u6613\u5185\u5b58\u6c60",id:"\u9879\u76ee-5\u7b80\u6613\u5185\u5b58\u6c60",level:2}];function a(n){const o={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(o.header,{children:(0,r.jsx)(o.h1,{id:"\u9879\u76ee\u5b9e\u6218",children:"\u9879\u76ee\u5b9e\u6218"})}),"\n",(0,r.jsx)(o.p,{children:"\u901a\u8fc7\u5b9e\u9645\u9879\u76ee\u5de9\u56fa C \u8bed\u8a00\u77e5\u8bc6\u3002"}),"\n",(0,r.jsx)(o.h2,{id:"\u9879\u76ee-1\u547d\u4ee4\u884c\u8ba1\u7b97\u5668",children:"\u9879\u76ee 1\uff1a\u547d\u4ee4\u884c\u8ba1\u7b97\u5668"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-c",children:"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\ndouble calculate(double a, char op, double b) {\n    switch (op) {\n        case '+': return a + b;\n        case '-': return a - b;\n        case '*': return a * b;\n        case '/': return b != 0 ? a / b : 0;\n        default: return 0;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 4) {\n        printf(\"\u7528\u6cd5: %s <\u6570\u5b57> <\u8fd0\u7b97\u7b26> <\u6570\u5b57>\\n\", argv[0]);\n        printf(\"\u793a\u4f8b: %s 10 + 5\\n\", argv[0]);\n        return 1;\n    }\n\n    double a = atof(argv[1]);\n    char op = argv[2][0];\n    double b = atof(argv[3]);\n\n    double result = calculate(a, op, b);\n    printf(\"%.2f %c %.2f = %.2f\\n\", a, op, b, result);\n\n    return 0;\n}\n"})}),"\n",(0,r.jsx)(o.h2,{id:"\u9879\u76ee-2\u901a\u8baf\u5f55\u7ba1\u7406",children:"\u9879\u76ee 2\uff1a\u901a\u8baf\u5f55\u7ba1\u7406"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CONTACTS 100\n#define NAME_LEN 50\n#define PHONE_LEN 20\n\ntypedef struct {\n    char name[NAME_LEN];\n    char phone[PHONE_LEN];\n} Contact;\n\ntypedef struct {\n    Contact contacts[MAX_CONTACTS];\n    int count;\n} AddressBook;\n\nvoid addContact(AddressBook *book) {\n    if (book->count >= MAX_CONTACTS) {\n        printf("\u901a\u8baf\u5f55\u5df2\u6ee1\\n");\n        return;\n    }\n\n    Contact *c = &book->contacts[book->count];\n    printf("\u59d3\u540d: ");\n    scanf("%49s", c->name);\n    printf("\u7535\u8bdd: ");\n    scanf("%19s", c->phone);\n    book->count++;\n    printf("\u6dfb\u52a0\u6210\u529f\\n");\n}\n\nvoid listContacts(AddressBook *book) {\n    printf("\\n=== \u901a\u8baf\u5f55 (%d\u4eba) ===\\n", book->count);\n    for (int i = 0; i < book->count; i++) {\n        printf("%d. %s - %s\\n", i + 1,\n               book->contacts[i].name,\n               book->contacts[i].phone);\n    }\n}\n\nvoid searchContact(AddressBook *book) {\n    char name[NAME_LEN];\n    printf("\u641c\u7d22\u59d3\u540d: ");\n    scanf("%49s", name);\n\n    for (int i = 0; i < book->count; i++) {\n        if (strstr(book->contacts[i].name, name)) {\n            printf("\u627e\u5230: %s - %s\\n",\n                   book->contacts[i].name,\n                   book->contacts[i].phone);\n            return;\n        }\n    }\n    printf("\u672a\u627e\u5230\\n");\n}\n\nint main(void) {\n    AddressBook book = {.count = 0};\n    int choice;\n\n    while (1) {\n        printf("\\n1.\u6dfb\u52a0 2.\u5217\u8868 3.\u641c\u7d22 0.\u9000\u51fa\\n\u9009\u62e9: ");\n        scanf("%d", &choice);\n\n        switch (choice) {\n            case 1: addContact(&book); break;\n            case 2: listContacts(&book); break;\n            case 3: searchContact(&book); break;\n            case 0: return 0;\n        }\n    }\n}\n'})}),"\n",(0,r.jsx)(o.h2,{id:"\u9879\u76ee-3\u7b80\u6613\u6587\u4ef6\u52a0\u5bc6",children:"\u9879\u76ee 3\uff1a\u7b80\u6613\u6587\u4ef6\u52a0\u5bc6"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid xorEncrypt(const char *in, const char *out, const char *key) {\n    FILE *fin = fopen(in, "rb");\n    FILE *fout = fopen(out, "wb");\n\n    if (!fin || !fout) {\n        printf("\u6587\u4ef6\u6253\u5f00\u5931\u8d25\\n");\n        return;\n    }\n\n    int keyLen = strlen(key);\n    int keyIdx = 0;\n    int ch;\n\n    while ((ch = fgetc(fin)) != EOF) {\n        fputc(ch ^ key[keyIdx], fout);\n        keyIdx = (keyIdx + 1) % keyLen;\n    }\n\n    fclose(fin);\n    fclose(fout);\n    printf("\u5b8c\u6210: %s -> %s\\n", in, out);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 4) {\n        printf("\u7528\u6cd5: %s <\u8f93\u5165\u6587\u4ef6> <\u8f93\u51fa\u6587\u4ef6> <\u5bc6\u94a5>\\n", argv[0]);\n        return 1;\n    }\n\n    xorEncrypt(argv[1], argv[2], argv[3]);\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(o.h2,{id:"\u9879\u76ee-4\u8bcd\u9891\u7edf\u8ba1",children:"\u9879\u76ee 4\uff1a\u8bcd\u9891\u7edf\u8ba1"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_WORDS 1000\n#define WORD_LEN 50\n\ntypedef struct {\n    char word[WORD_LEN];\n    int count;\n} WordCount;\n\nWordCount words[MAX_WORDS];\nint wordCount = 0;\n\nvoid addWord(const char *word) {\n    // \u67e5\u627e\u662f\u5426\u5df2\u5b58\u5728\n    for (int i = 0; i < wordCount; i++) {\n        if (strcasecmp(words[i].word, word) == 0) {\n            words[i].count++;\n            return;\n        }\n    }\n\n    // \u6dfb\u52a0\u65b0\u8bcd\n    if (wordCount < MAX_WORDS) {\n        strcpy(words[wordCount].word, word);\n        words[wordCount].count = 1;\n        wordCount++;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    return ((WordCount*)b)->count - ((WordCount*)a)->count;\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf("\u7528\u6cd5: %s <\u6587\u4ef6\u540d>\\n", argv[0]);\n        return 1;\n    }\n\n    FILE *fp = fopen(argv[1], "r");\n    if (!fp) {\n        printf("\u65e0\u6cd5\u6253\u5f00\u6587\u4ef6\\n");\n        return 1;\n    }\n\n    char word[WORD_LEN];\n    int idx = 0;\n    int ch;\n\n    while ((ch = fgetc(fp)) != EOF) {\n        if (isalpha(ch)) {\n            if (idx < WORD_LEN - 1) {\n                word[idx++] = tolower(ch);\n            }\n        } else if (idx > 0) {\n            word[idx] = \'\\0\';\n            addWord(word);\n            idx = 0;\n        }\n    }\n    fclose(fp);\n\n    // \u6392\u5e8f\u5e76\u8f93\u51fa\u524d10\n    qsort(words, wordCount, sizeof(WordCount), compare);\n\n    printf("\\n=== \u8bcd\u9891\u7edf\u8ba1 Top 10 ===\\n");\n    for (int i = 0; i < 10 && i < wordCount; i++) {\n        printf("%2d. %-15s %d\\n", i+1, words[i].word, words[i].count);\n    }\n\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(o.h2,{id:"\u9879\u76ee-5\u7b80\u6613\u5185\u5b58\u6c60",children:"\u9879\u76ee 5\uff1a\u7b80\u6613\u5185\u5b58\u6c60"}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define POOL_SIZE 4096\n#define BLOCK_SIZE 64\n\ntypedef struct Block {\n    struct Block *next;\n} Block;\n\ntypedef struct {\n    char memory[POOL_SIZE];\n    Block *freeList;\n} MemoryPool;\n\nMemoryPool* pool_create(void) {\n    MemoryPool *pool = malloc(sizeof(MemoryPool));\n    pool->freeList = NULL;\n\n    // \u521d\u59cb\u5316\u7a7a\u95f2\u94fe\u8868\n    int numBlocks = POOL_SIZE / BLOCK_SIZE;\n    for (int i = 0; i < numBlocks; i++) {\n        Block *block = (Block*)(pool->memory + i * BLOCK_SIZE);\n        block->next = pool->freeList;\n        pool->freeList = block;\n    }\n\n    return pool;\n}\n\nvoid* pool_alloc(MemoryPool *pool) {\n    if (pool->freeList == NULL) {\n        return NULL;\n    }\n\n    Block *block = pool->freeList;\n    pool->freeList = block->next;\n    return block;\n}\n\nvoid pool_free(MemoryPool *pool, void *ptr) {\n    Block *block = (Block*)ptr;\n    block->next = pool->freeList;\n    pool->freeList = block;\n}\n\nvoid pool_destroy(MemoryPool *pool) {\n    free(pool);\n}\n\nint main(void) {\n    MemoryPool *pool = pool_create();\n\n    // \u5206\u914d\u4e00\u4e9b\u5185\u5b58\n    void *p1 = pool_alloc(pool);\n    void *p2 = pool_alloc(pool);\n    void *p3 = pool_alloc(pool);\n\n    printf("\u5206\u914d\u4e86 3 \u5757\u5185\u5b58\\n");\n\n    // \u91ca\u653e\n    pool_free(pool, p2);\n    printf("\u91ca\u653e\u4e86 1 \u5757\u5185\u5b58\\n");\n\n    // \u518d\u6b21\u5206\u914d\n    void *p4 = pool_alloc(pool);\n    printf("\u518d\u6b21\u5206\u914d: %s\\n", p4 == p2 ? "\u590d\u7528\u4e86\u4e4b\u524d\u7684\u5757" : "\u65b0\u5757");\n\n    pool_destroy(pool);\n    return 0;\n}\n'})}),"\n",(0,r.jsx)(o.p,{children:"\u795d\u8d3a\uff01\u4f60\u5df2\u7ecf\u5b8c\u6210\u4e86 C \u8bed\u8a00\u7684\u5b66\u4e60\uff01\ud83c\udf89"})]})}function p(n={}){const{wrapper:o}={...(0,i.R)(),...n.components};return o?(0,r.jsx)(o,{...n,children:(0,r.jsx)(a,{...n})}):a(n)}}}]);