"use strict";(globalThis.webpackChunkto_lib_github_io=globalThis.webpackChunkto_lib_github_io||[]).push([[44192],{48885:(n,e,t)=>{t.d(e,{R:()=>r,x:()=>s});var i=t(99378);const d={},l=i.createContext(d);function r(n){const e=i.useContext(l);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(d):n.components||d:r(n.components),i.createElement(l.Provider,{value:e},n.children)}},62569:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>s,default:()=>c,frontMatter:()=>r,metadata:()=>i,toc:()=>_});const i=JSON.parse('{"id":"c/embedded","title":"\u5d4c\u5165\u5f0f\u7f16\u7a0b","description":"\u5d4c\u5165\u5f0f\u7cfb\u7edf\u662f C \u8bed\u8a00\u6700\u91cd\u8981\u7684\u5e94\u7528\u9886\u57df\u4e4b\u4e00\uff0c\u7528\u4e8e\u5f00\u53d1\u5355\u7247\u673a\u3001\u7269\u8054\u7f51\u8bbe\u5907\u3001\u6c7d\u8f66\u7535\u5b50\u7b49\u3002","source":"@site/docs/c/embedded.md","sourceDirName":"c","slug":"/c/embedded","permalink":"/docs/c/embedded","draft":false,"unlisted":false,"editUrl":"https://github.com/to-lib/to-lib.github.io/tree/main/docs/c/embedded.md","tags":[],"version":"current","sidebarPosition":16,"frontMatter":{"sidebar_position":16,"title":"\u5d4c\u5165\u5f0f\u7f16\u7a0b"},"sidebar":"c","previous":{"title":"\u591a\u6587\u4ef6\u7f16\u7a0b","permalink":"/docs/c/multi-file"},"next":{"title":"\u7f51\u7edc\u7f16\u7a0b","permalink":"/docs/c/network-programming"}}');var d=t(22714),l=t(48885);const r={sidebar_position:16,title:"\u5d4c\u5165\u5f0f\u7f16\u7a0b"},s="\u5d4c\u5165\u5f0f C \u7f16\u7a0b",a={},_=[{value:"\u5d4c\u5165\u5f0f\u7cfb\u7edf\u6982\u8ff0",id:"\u5d4c\u5165\u5f0f\u7cfb\u7edf\u6982\u8ff0",level:2},{value:"\u4ec0\u4e48\u662f\u5d4c\u5165\u5f0f\u7cfb\u7edf",id:"\u4ec0\u4e48\u662f\u5d4c\u5165\u5f0f\u7cfb\u7edf",level:3},{value:"\u5e38\u89c1\u5d4c\u5165\u5f0f\u5e73\u53f0",id:"\u5e38\u89c1\u5d4c\u5165\u5f0f\u5e73\u53f0",level:3},{value:"\u786c\u4ef6\u5bc4\u5b58\u5668\u64cd\u4f5c",id:"\u786c\u4ef6\u5bc4\u5b58\u5668\u64cd\u4f5c",level:2},{value:"\u5bc4\u5b58\u5668\u57fa\u7840",id:"\u5bc4\u5b58\u5668\u57fa\u7840",level:3},{value:"volatile \u5173\u952e\u5b57",id:"volatile-\u5173\u952e\u5b57",level:3},{value:"\u5bc4\u5b58\u5668\u7ed3\u6784\u4f53\u6620\u5c04",id:"\u5bc4\u5b58\u5668\u7ed3\u6784\u4f53\u6620\u5c04",level:3},{value:"\u4e2d\u65ad\u5904\u7406",id:"\u4e2d\u65ad\u5904\u7406",level:2},{value:"\u4e2d\u65ad\u5411\u91cf\u8868",id:"\u4e2d\u65ad\u5411\u91cf\u8868",level:3},{value:"\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f",id:"\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f",level:3},{value:"\u4e34\u754c\u533a\u4fdd\u62a4",id:"\u4e34\u754c\u533a\u4fdd\u62a4",level:3},{value:"\u5185\u5b58\u7ba1\u7406",id:"\u5185\u5b58\u7ba1\u7406",level:2},{value:"\u5185\u5b58\u5e03\u5c40",id:"\u5185\u5b58\u5e03\u5c40",level:3},{value:"\u9759\u6001\u5185\u5b58\u5206\u914d",id:"\u9759\u6001\u5185\u5b58\u5206\u914d",level:3},{value:"\u5916\u8bbe\u9a71\u52a8",id:"\u5916\u8bbe\u9a71\u52a8",level:2},{value:"GPIO \u9a71\u52a8\u793a\u4f8b",id:"gpio-\u9a71\u52a8\u793a\u4f8b",level:3},{value:"UART \u9a71\u52a8\u793a\u4f8b",id:"uart-\u9a71\u52a8\u793a\u4f8b",level:3},{value:"\u5b9e\u65f6\u64cd\u4f5c\u7cfb\u7edf\u57fa\u7840",id:"\u5b9e\u65f6\u64cd\u4f5c\u7cfb\u7edf\u57fa\u7840",level:2},{value:"\u7b80\u5355\u4efb\u52a1\u8c03\u5ea6",id:"\u7b80\u5355\u4efb\u52a1\u8c03\u5ea6",level:3},{value:"\u72b6\u6001\u673a",id:"\u72b6\u6001\u673a",level:3},{value:"\u8c03\u8bd5\u6280\u5de7",id:"\u8c03\u8bd5\u6280\u5de7",level:2},{value:"\u4e32\u53e3\u8c03\u8bd5",id:"\u4e32\u53e3\u8c03\u8bd5",level:3},{value:"GPIO \u8c03\u8bd5",id:"gpio-\u8c03\u8bd5",level:3},{value:"\u6700\u4f73\u5b9e\u8df5",id:"\u6700\u4f73\u5b9e\u8df5",level:2}];function o(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(e.header,{children:(0,d.jsx)(e.h1,{id:"\u5d4c\u5165\u5f0f-c-\u7f16\u7a0b",children:"\u5d4c\u5165\u5f0f C \u7f16\u7a0b"})}),"\n",(0,d.jsx)(e.p,{children:"\u5d4c\u5165\u5f0f\u7cfb\u7edf\u662f C \u8bed\u8a00\u6700\u91cd\u8981\u7684\u5e94\u7528\u9886\u57df\u4e4b\u4e00\uff0c\u7528\u4e8e\u5f00\u53d1\u5355\u7247\u673a\u3001\u7269\u8054\u7f51\u8bbe\u5907\u3001\u6c7d\u8f66\u7535\u5b50\u7b49\u3002"}),"\n",(0,d.jsx)(e.h2,{id:"\u5d4c\u5165\u5f0f\u7cfb\u7edf\u6982\u8ff0",children:"\u5d4c\u5165\u5f0f\u7cfb\u7edf\u6982\u8ff0"}),"\n",(0,d.jsx)(e.h3,{id:"\u4ec0\u4e48\u662f\u5d4c\u5165\u5f0f\u7cfb\u7edf",children:"\u4ec0\u4e48\u662f\u5d4c\u5165\u5f0f\u7cfb\u7edf"}),"\n",(0,d.jsx)(e.p,{children:"\u5d4c\u5165\u5f0f\u7cfb\u7edf\u662f\u4e13\u7528\u4e8e\u6267\u884c\u7279\u5b9a\u529f\u80fd\u7684\u8ba1\u7b97\u673a\u7cfb\u7edf\uff0c\u5177\u6709\u4ee5\u4e0b\u7279\u70b9\uff1a"}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.strong,{children:"\u8d44\u6e90\u53d7\u9650"})," - \u5185\u5b58\u548c\u5b58\u50a8\u7a7a\u95f4\u6709\u9650"]}),"\n",(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.strong,{children:"\u5b9e\u65f6\u6027"})," - \u9700\u8981\u5728\u89c4\u5b9a\u65f6\u95f4\u5185\u54cd\u5e94"]}),"\n",(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.strong,{children:"\u4f4e\u529f\u8017"})," - \u901a\u5e38\u4f7f\u7528\u7535\u6c60\u4f9b\u7535"]}),"\n",(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.strong,{children:"\u9ad8\u53ef\u9760\u6027"})," - \u8981\u6c42\u957f\u65f6\u95f4\u7a33\u5b9a\u8fd0\u884c"]}),"\n"]}),"\n",(0,d.jsx)(e.h3,{id:"\u5e38\u89c1\u5d4c\u5165\u5f0f\u5e73\u53f0",children:"\u5e38\u89c1\u5d4c\u5165\u5f0f\u5e73\u53f0"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,d.jsxs)(e.table,{children:[(0,d.jsx)(e.thead,{children:(0,d.jsxs)(e.tr,{children:[(0,d.jsx)(e.th,{children:"\u5e73\u53f0"}),(0,d.jsx)(e.th,{children:"\u4f4d\u5bbd"}),(0,d.jsx)(e.th,{children:"\u5178\u578b\u82af\u7247"}),(0,d.jsx)(e.th,{children:"\u5e94\u7528\u573a\u666f"})]})}),(0,d.jsxs)(e.tbody,{children:[(0,d.jsxs)(e.tr,{children:[(0,d.jsx)(e.td,{children:"8051"}),(0,d.jsx)(e.td,{children:"8 \u4f4d"}),(0,d.jsx)(e.td,{children:"AT89C51"}),(0,d.jsx)(e.td,{children:"\u7b80\u5355\u63a7\u5236"})]}),(0,d.jsxs)(e.tr,{children:[(0,d.jsx)(e.td,{children:"AVR"}),(0,d.jsx)(e.td,{children:"8 \u4f4d"}),(0,d.jsx)(e.td,{children:"ATmega328"}),(0,d.jsx)(e.td,{children:"Arduino"})]}),(0,d.jsxs)(e.tr,{children:[(0,d.jsx)(e.td,{children:"ARM Cortex-M"}),(0,d.jsx)(e.td,{children:"32 \u4f4d"}),(0,d.jsx)(e.td,{children:"STM32, LPC"}),(0,d.jsx)(e.td,{children:"\u5de5\u4e1a\u63a7\u5236"})]}),(0,d.jsxs)(e.tr,{children:[(0,d.jsx)(e.td,{children:"ARM Cortex-A"}),(0,d.jsx)(e.td,{children:"32/64 \u4f4d"}),(0,d.jsx)(e.td,{children:"Raspberry Pi"}),(0,d.jsx)(e.td,{children:"\u590d\u6742\u5e94\u7528"})]}),(0,d.jsxs)(e.tr,{children:[(0,d.jsx)(e.td,{children:"RISC-V"}),(0,d.jsx)(e.td,{children:"32/64 \u4f4d"}),(0,d.jsx)(e.td,{children:"ESP32-C3"}),(0,d.jsx)(e.td,{children:"\u65b0\u5174\u5e73\u53f0"})]})]})]}),"\n",(0,d.jsx)(e.h2,{id:"\u786c\u4ef6\u5bc4\u5b58\u5668\u64cd\u4f5c",children:"\u786c\u4ef6\u5bc4\u5b58\u5668\u64cd\u4f5c"}),"\n",(0,d.jsx)(e.h3,{id:"\u5bc4\u5b58\u5668\u57fa\u7840",children:"\u5bc4\u5b58\u5668\u57fa\u7840"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"#include <stdint.h>\n\n// \u5bc4\u5b58\u5668\u5730\u5740\u5b9a\u4e49\n#define GPIO_BASE       0x40020000\n#define GPIO_MODER      (*(volatile uint32_t *)(GPIO_BASE + 0x00))\n#define GPIO_ODR        (*(volatile uint32_t *)(GPIO_BASE + 0x14))\n#define GPIO_IDR        (*(volatile uint32_t *)(GPIO_BASE + 0x10))\n\n// \u4f4d\u64cd\u4f5c\u5b8f\n#define BIT(n)          (1UL << (n))\n#define SET_BIT(reg, n)   ((reg) |= BIT(n))\n#define CLEAR_BIT(reg, n) ((reg) &= ~BIT(n))\n#define READ_BIT(reg, n)  (((reg) >> (n)) & 1)\n#define TOGGLE_BIT(reg, n) ((reg) ^= BIT(n))\n\n// \u8bbe\u7f6e GPIO \u5f15\u811a 5 \u4e3a\u8f93\u51fa\u6a21\u5f0f\nvoid gpio_init(void) {\n    // \u914d\u7f6e\u6a21\u5f0f\u5bc4\u5b58\u5668\n    GPIO_MODER &= ~(0x3 << 10);  // \u6e05\u9664\u4f4d [11:10]\n    GPIO_MODER |= (0x1 << 10);   // \u8bbe\u7f6e\u4e3a\u8f93\u51fa\u6a21\u5f0f\n}\n\n// \u63a7\u5236 LED\nvoid led_on(void) {\n    SET_BIT(GPIO_ODR, 5);\n}\n\nvoid led_off(void) {\n    CLEAR_BIT(GPIO_ODR, 5);\n}\n\nvoid led_toggle(void) {\n    TOGGLE_BIT(GPIO_ODR, 5);\n}\n"})}),"\n",(0,d.jsx)(e.h3,{id:"volatile-\u5173\u952e\u5b57",children:"volatile \u5173\u952e\u5b57"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"// volatile \u544a\u8bc9\u7f16\u8bd1\u5668\u53d8\u91cf\u53ef\u80fd\u88ab\u5916\u90e8\u56e0\u7d20\u6539\u53d8\n// \u9632\u6b62\u7f16\u8bd1\u5668\u4f18\u5316\u6389\u5bf9\u8fd9\u4e9b\u53d8\u91cf\u7684\u8bfb\u5199\n\n// \u786c\u4ef6\u5bc4\u5b58\u5668\u5fc5\u987b\u4f7f\u7528 volatile\nvolatile uint32_t *TIMER_COUNT = (volatile uint32_t *)0x40000024;\n\n// \u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u4fee\u6539\u7684\u53d8\u91cf\nvolatile int interrupt_flag = 0;\n\nvoid wait_for_interrupt(void) {\n    // \u6ca1\u6709 volatile\uff0c\u7f16\u8bd1\u5668\u53ef\u80fd\u4f18\u5316\u4e3a\u65e0\u9650\u5faa\u73af\n    while (!interrupt_flag) {\n        // \u7b49\u5f85\n    }\n    interrupt_flag = 0;\n}\n\n// ISR (Interrupt Service Routine)\nvoid TIMER_IRQHandler(void) {\n    interrupt_flag = 1;\n}\n"})}),"\n",(0,d.jsx)(e.h3,{id:"\u5bc4\u5b58\u5668\u7ed3\u6784\u4f53\u6620\u5c04",children:"\u5bc4\u5b58\u5668\u7ed3\u6784\u4f53\u6620\u5c04"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"#include <stdint.h>\n\n// GPIO \u5bc4\u5b58\u5668\u7ed3\u6784\u4f53\ntypedef struct {\n    volatile uint32_t MODER;    // \u6a21\u5f0f\u5bc4\u5b58\u5668\n    volatile uint32_t OTYPER;   // \u8f93\u51fa\u7c7b\u578b\n    volatile uint32_t OSPEEDR;  // \u8f93\u51fa\u901f\u5ea6\n    volatile uint32_t PUPDR;    // \u4e0a\u62c9/\u4e0b\u62c9\n    volatile uint32_t IDR;      // \u8f93\u5165\u6570\u636e\n    volatile uint32_t ODR;      // \u8f93\u51fa\u6570\u636e\n    volatile uint32_t BSRR;     // \u4f4d\u8bbe\u7f6e/\u590d\u4f4d\n    volatile uint32_t LCKR;     // \u9501\u5b9a\n    volatile uint32_t AFR[2];   // \u590d\u7528\u529f\u80fd\n} GPIO_TypeDef;\n\n#define GPIOA ((GPIO_TypeDef *)0x40020000)\n#define GPIOB ((GPIO_TypeDef *)0x40020400)\n\n// \u4f7f\u7528\u7ed3\u6784\u4f53\u8bbf\u95ee\u5bc4\u5b58\u5668\nvoid gpio_example(void) {\n    GPIOA->MODER |= (1 << 10);   // PA5 \u8f93\u51fa\u6a21\u5f0f\n    GPIOA->ODR |= (1 << 5);      // PA5 \u9ad8\u7535\u5e73\n    GPIOA->BSRR = (1 << 5);      // \u539f\u5b50\u64cd\u4f5c\u8bbe\u7f6e PA5\n    GPIOA->BSRR = (1 << 21);     // \u539f\u5b50\u64cd\u4f5c\u6e05\u9664 PA5\n}\n"})}),"\n",(0,d.jsx)(e.h2,{id:"\u4e2d\u65ad\u5904\u7406",children:"\u4e2d\u65ad\u5904\u7406"}),"\n",(0,d.jsx)(e.mermaid,{value:"graph TD\n    Main[Main Loop] --\x3e|Normal Execution| Task[Task Execution]\n    Task --\x3e Main\n\n    ISR((Interrupt)) --o Main\n    ISR --o Task\n\n    subgraph Interrupt Handler\n    Context[Save Context] --\x3e Handle[Execute ISR]\n    Handle --\x3e Restore[Restore Context]\n    end\n\n    Main -.->|Hardware Trigger| Context\n    Restore -.->|Return| Main\n\n    style ISR fill:#ff9999\n    style Handle fill:#ff9999"}),"\n",(0,d.jsx)(e.h3,{id:"\u4e2d\u65ad\u5411\u91cf\u8868",children:"\u4e2d\u65ad\u5411\u91cf\u8868"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'#include <stdint.h>\n\n// \u51fd\u6570\u6307\u9488\u7c7b\u578b\ntypedef void (*IRQHandler)(void);\n\n// \u4e2d\u65ad\u5411\u91cf\u8868\uff08\u653e\u5728\u56fa\u5b9a\u5730\u5740\uff09\n__attribute__((section(".isr_vector")))\nconst IRQHandler vector_table[] = {\n    (IRQHandler)0x20010000,  // \u521d\u59cb\u6808\u6307\u9488\n    Reset_Handler,           // \u590d\u4f4d\u5904\u7406\u51fd\u6570\n    NMI_Handler,\n    HardFault_Handler,\n    // ... \u5176\u4ed6\u4e2d\u65ad\u5411\u91cf\n    TIMER0_IRQHandler,\n    UART0_IRQHandler,\n};\n\n// \u9ed8\u8ba4\u5904\u7406\u51fd\u6570\nvoid Default_Handler(void) {\n    while (1);  // \u6b7b\u5faa\u73af\n}\n\n// \u5f31\u7b26\u53f7\uff0c\u53ef\u88ab\u7528\u6237\u8986\u76d6\n__attribute__((weak, alias("Default_Handler")))\nvoid TIMER0_IRQHandler(void);\n'})}),"\n",(0,d.jsx)(e.h3,{id:"\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f",children:"\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"#include <stdint.h>\n\n// \u5171\u4eab\u53d8\u91cf\u5fc5\u987b\u4f7f\u7528 volatile\nvolatile uint32_t tick_count = 0;\nvolatile uint8_t rx_buffer[64];\nvolatile uint8_t rx_index = 0;\n\n// \u5b9a\u65f6\u5668\u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\nvoid SysTick_Handler(void) {\n    tick_count++;\n}\n\n// UART \u63a5\u6536\u4e2d\u65ad\nvoid UART_IRQHandler(void) {\n    // \u68c0\u67e5\u4e2d\u65ad\u6807\u5fd7\n    if (UART->SR & UART_SR_RXNE) {\n        uint8_t data = UART->DR;  // \u8bfb\u53d6\u6570\u636e\u4f1a\u6e05\u9664\u6807\u5fd7\n\n        if (rx_index < sizeof(rx_buffer)) {\n            rx_buffer[rx_index++] = data;\n        }\n    }\n}\n\n// \u5ef6\u65f6\u51fd\u6570\nvoid delay_ms(uint32_t ms) {\n    uint32_t start = tick_count;\n    while ((tick_count - start) < ms);\n}\n"})}),"\n",(0,d.jsx)(e.h3,{id:"\u4e34\u754c\u533a\u4fdd\u62a4",children:"\u4e34\u754c\u533a\u4fdd\u62a4"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'#include <stdint.h>\n\n// \u7981\u7528/\u542f\u7528\u4e2d\u65ad\nstatic inline uint32_t disable_irq(void) {\n    uint32_t primask;\n    __asm volatile ("MRS %0, primask" : "=r" (primask));\n    __asm volatile ("CPSID i");\n    return primask;\n}\n\nstatic inline void restore_irq(uint32_t primask) {\n    __asm volatile ("MSR primask, %0" : : "r" (primask));\n}\n\n// \u4f7f\u7528\u4e34\u754c\u533a\u4fdd\u62a4\u5171\u4eab\u8d44\u6e90\nvolatile int shared_counter = 0;\n\nvoid safe_increment(void) {\n    uint32_t state = disable_irq();\n\n    shared_counter++;  // \u4e34\u754c\u533a\n\n    restore_irq(state);\n}\n\n// \u5b8f\u7b80\u5316\u4e34\u754c\u533a\n#define CRITICAL_SECTION_BEGIN() uint32_t __irq_state = disable_irq()\n#define CRITICAL_SECTION_END()   restore_irq(__irq_state)\n\nvoid example(void) {\n    CRITICAL_SECTION_BEGIN();\n    // \u4e34\u754c\u533a\u4ee3\u7801\n    CRITICAL_SECTION_END();\n}\n'})}),"\n",(0,d.jsx)(e.h2,{id:"\u5185\u5b58\u7ba1\u7406",children:"\u5185\u5b58\u7ba1\u7406"}),"\n",(0,d.jsx)(e.h3,{id:"\u5185\u5b58\u5e03\u5c40",children:"\u5185\u5b58\u5e03\u5c40"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'// \u5178\u578b\u7684\u5d4c\u5165\u5f0f\u5185\u5b58\u5e03\u5c40\uff08\u94fe\u63a5\u811a\u672c\u5b9a\u4e49\uff09\n/*\nMEMORY {\n    FLASH (rx)  : ORIGIN = 0x08000000, LENGTH = 256K\n    RAM   (rwx) : ORIGIN = 0x20000000, LENGTH = 64K\n}\n\nSECTIONS {\n    .text   : { *(.text*) } > FLASH\n    .rodata : { *(.rodata*) } > FLASH\n    .data   : { *(.data*) } > RAM AT > FLASH\n    .bss    : { *(.bss*) } > RAM\n    .stack  : { . = . + 0x1000; } > RAM\n}\n*/\n\n// \u5728\u4ee3\u7801\u4e2d\u6307\u5b9a\u6bb5\n__attribute__((section(".data")))\nint initialized_var = 42;\n\n__attribute__((section(".bss")))\nint uninitialized_var;\n\n__attribute__((section(".rodata")))\nconst char message[] = "Hello, Embedded!";\n'})}),"\n",(0,d.jsx)(e.h3,{id:"\u9759\u6001\u5185\u5b58\u5206\u914d",children:"\u9759\u6001\u5185\u5b58\u5206\u914d"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"#include <stdint.h>\n\n// \u5d4c\u5165\u5f0f\u7cfb\u7edf\u901a\u5e38\u907f\u514d\u52a8\u6001\u5185\u5b58\u5206\u914d\n// \u4f7f\u7528\u9759\u6001\u5206\u914d\u548c\u5185\u5b58\u6c60\n\n// \u9759\u6001\u7f13\u51b2\u533a\nstatic uint8_t tx_buffer[256];\nstatic uint8_t rx_buffer[256];\n\n// \u7b80\u5355\u5185\u5b58\u6c60\n#define POOL_BLOCK_SIZE  32\n#define POOL_BLOCK_COUNT 16\n\ntypedef struct {\n    uint8_t blocks[POOL_BLOCK_COUNT][POOL_BLOCK_SIZE];\n    uint8_t used[POOL_BLOCK_COUNT];\n} MemPool;\n\nstatic MemPool pool = {0};\n\nvoid* pool_alloc(void) {\n    for (int i = 0; i < POOL_BLOCK_COUNT; i++) {\n        if (!pool.used[i]) {\n            pool.used[i] = 1;\n            return pool.blocks[i];\n        }\n    }\n    return NULL;\n}\n\nvoid pool_free(void *ptr) {\n    for (int i = 0; i < POOL_BLOCK_COUNT; i++) {\n        if (ptr == pool.blocks[i]) {\n            pool.used[i] = 0;\n            return;\n        }\n    }\n}\n"})}),"\n",(0,d.jsx)(e.h2,{id:"\u5916\u8bbe\u9a71\u52a8",children:"\u5916\u8bbe\u9a71\u52a8"}),"\n",(0,d.jsx)(e.h3,{id:"gpio-\u9a71\u52a8\u793a\u4f8b",children:"GPIO \u9a71\u52a8\u793a\u4f8b"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"#include <stdint.h>\n\ntypedef enum {\n    GPIO_MODE_INPUT,\n    GPIO_MODE_OUTPUT,\n    GPIO_MODE_AF,\n    GPIO_MODE_ANALOG\n} GPIO_Mode;\n\ntypedef enum {\n    GPIO_PULL_NONE,\n    GPIO_PULL_UP,\n    GPIO_PULL_DOWN\n} GPIO_Pull;\n\ntypedef struct {\n    uint8_t pin;\n    GPIO_Mode mode;\n    GPIO_Pull pull;\n} GPIO_Config;\n\nvoid GPIO_Init(GPIO_TypeDef *port, GPIO_Config *config) {\n    uint32_t pin = config->pin;\n\n    // \u6e05\u9664\u5e76\u8bbe\u7f6e\u6a21\u5f0f\n    port->MODER &= ~(0x3 << (pin * 2));\n    port->MODER |= (config->mode << (pin * 2));\n\n    // \u8bbe\u7f6e\u4e0a\u62c9/\u4e0b\u62c9\n    port->PUPDR &= ~(0x3 << (pin * 2));\n    port->PUPDR |= (config->pull << (pin * 2));\n}\n\nvoid GPIO_Write(GPIO_TypeDef *port, uint8_t pin, uint8_t value) {\n    if (value) {\n        port->BSRR = (1 << pin);\n    } else {\n        port->BSRR = (1 << (pin + 16));\n    }\n}\n\nuint8_t GPIO_Read(GPIO_TypeDef *port, uint8_t pin) {\n    return (port->IDR >> pin) & 1;\n}\n"})}),"\n",(0,d.jsx)(e.h3,{id:"uart-\u9a71\u52a8\u793a\u4f8b",children:"UART \u9a71\u52a8\u793a\u4f8b"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"#include <stdint.h>\n\ntypedef struct {\n    volatile uint32_t SR;   // \u72b6\u6001\u5bc4\u5b58\u5668\n    volatile uint32_t DR;   // \u6570\u636e\u5bc4\u5b58\u5668\n    volatile uint32_t BRR;  // \u6ce2\u7279\u7387\u5bc4\u5b58\u5668\n    volatile uint32_t CR1;  // \u63a7\u5236\u5bc4\u5b58\u56681\n    volatile uint32_t CR2;  // \u63a7\u5236\u5bc4\u5b58\u56682\n    volatile uint32_t CR3;  // \u63a7\u5236\u5bc4\u5b58\u56683\n} UART_TypeDef;\n\n#define UART1 ((UART_TypeDef *)0x40011000)\n\n// \u72b6\u6001\u4f4d\n#define UART_SR_TXE   (1 << 7)\n#define UART_SR_RXNE  (1 << 5)\n\nvoid UART_Init(uint32_t baudrate) {\n    // \u5047\u8bbe\u65f6\u949f\u4e3a 16MHz\n    UART1->BRR = 16000000 / baudrate;\n    UART1->CR1 = (1 << 13) |  // \u4f7f\u80fd UART\n                 (1 << 3)  |  // \u4f7f\u80fd\u53d1\u9001\n                 (1 << 2);    // \u4f7f\u80fd\u63a5\u6536\n}\n\nvoid UART_SendByte(uint8_t data) {\n    while (!(UART1->SR & UART_SR_TXE));  // \u7b49\u5f85\u53d1\u9001\u7f13\u51b2\u533a\u7a7a\n    UART1->DR = data;\n}\n\nuint8_t UART_ReceiveByte(void) {\n    while (!(UART1->SR & UART_SR_RXNE));  // \u7b49\u5f85\u63a5\u6536\u6570\u636e\n    return UART1->DR;\n}\n\nvoid UART_SendString(const char *str) {\n    while (*str) {\n        UART_SendByte(*str++);\n    }\n}\n\n// printf \u91cd\u5b9a\u5411\nint _write(int fd, char *ptr, int len) {\n    for (int i = 0; i < len; i++) {\n        UART_SendByte(ptr[i]);\n    }\n    return len;\n}\n"})}),"\n",(0,d.jsx)(e.h2,{id:"\u5b9e\u65f6\u64cd\u4f5c\u7cfb\u7edf\u57fa\u7840",children:"\u5b9e\u65f6\u64cd\u4f5c\u7cfb\u7edf\u57fa\u7840"}),"\n",(0,d.jsx)(e.h3,{id:"\u7b80\u5355\u4efb\u52a1\u8c03\u5ea6",children:"\u7b80\u5355\u4efb\u52a1\u8c03\u5ea6"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"#include <stdint.h>\n\n#define MAX_TASKS 8\n\ntypedef void (*TaskFunc)(void);\n\ntypedef struct {\n    TaskFunc func;\n    uint32_t period;      // \u6267\u884c\u5468\u671f\uff08ms\uff09\n    uint32_t last_run;    // \u4e0a\u6b21\u6267\u884c\u65f6\u95f4\n} Task;\n\nstatic Task tasks[MAX_TASKS];\nstatic uint8_t task_count = 0;\nvolatile uint32_t system_tick = 0;\n\nvoid scheduler_add_task(TaskFunc func, uint32_t period) {\n    if (task_count < MAX_TASKS) {\n        tasks[task_count].func = func;\n        tasks[task_count].period = period;\n        tasks[task_count].last_run = 0;\n        task_count++;\n    }\n}\n\nvoid scheduler_run(void) {\n    while (1) {\n        uint32_t now = system_tick;\n\n        for (int i = 0; i < task_count; i++) {\n            if ((now - tasks[i].last_run) >= tasks[i].period) {\n                tasks[i].func();\n                tasks[i].last_run = now;\n            }\n        }\n    }\n}\n\n// \u4f7f\u7528\u793a\u4f8b\nvoid task_led(void) {\n    led_toggle();\n}\n\nvoid task_sensor(void) {\n    read_sensor();\n}\n\nint main(void) {\n    system_init();\n\n    scheduler_add_task(task_led, 500);     // 500ms\n    scheduler_add_task(task_sensor, 100);  // 100ms\n\n    scheduler_run();\n    return 0;\n}\n"})}),"\n",(0,d.jsx)(e.h3,{id:"\u72b6\u6001\u673a",children:"\u72b6\u6001\u673a"}),"\n",(0,d.jsx)(e.mermaid,{value:"stateDiagram-v2\n    [*] --\x3e IDLE\n    IDLE --\x3e RUNNING : START\n    RUNNING --\x3e PAUSED : PAUSE\n    PAUSED --\x3e RUNNING : RESUME\n    RUNNING --\x3e IDLE : STOP\n    PAUSED --\x3e IDLE : STOP\n    RUNNING --\x3e ERROR : ERROR\n    ERROR --\x3e IDLE : STOP"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"typedef enum {\n    STATE_IDLE,\n    STATE_RUNNING,\n    STATE_PAUSED,\n    STATE_ERROR\n} State;\n\ntypedef enum {\n    EVENT_START,\n    EVENT_PAUSE,\n    EVENT_RESUME,\n    EVENT_STOP,\n    EVENT_ERROR\n} Event;\n\ntypedef struct {\n    State current_state;\n} StateMachine;\n\nvoid sm_init(StateMachine *sm) {\n    sm->current_state = STATE_IDLE;\n}\n\nvoid sm_process_event(StateMachine *sm, Event event) {\n    State next = sm->current_state;\n\n    switch (sm->current_state) {\n        case STATE_IDLE:\n            if (event == EVENT_START) next = STATE_RUNNING;\n            break;\n        case STATE_RUNNING:\n            if (event == EVENT_PAUSE) next = STATE_PAUSED;\n            if (event == EVENT_STOP) next = STATE_IDLE;\n            if (event == EVENT_ERROR) next = STATE_ERROR;\n            break;\n        case STATE_PAUSED:\n            if (event == EVENT_RESUME) next = STATE_RUNNING;\n            if (event == EVENT_STOP) next = STATE_IDLE;\n            break;\n        case STATE_ERROR:\n            if (event == EVENT_STOP) next = STATE_IDLE;\n            break;\n    }\n\n    if (next != sm->current_state) {\n        // \u72b6\u6001\u8f6c\u6362\u56de\u8c03\n        on_state_change(sm->current_state, next);\n        sm->current_state = next;\n    }\n}\n"})}),"\n",(0,d.jsx)(e.h2,{id:"\u8c03\u8bd5\u6280\u5de7",children:"\u8c03\u8bd5\u6280\u5de7"}),"\n",(0,d.jsx)(e.h3,{id:"\u4e32\u53e3\u8c03\u8bd5",children:"\u4e32\u53e3\u8c03\u8bd5"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:'#include <stdio.h>\n#include <stdarg.h>\n\n// \u8c03\u8bd5\u7ea7\u522b\n#define DEBUG_LEVEL 2\n\n#if DEBUG_LEVEL >= 1\n    #define DEBUG1(fmt, ...) printf("[D1] " fmt "\\n", ##__VA_ARGS__)\n#else\n    #define DEBUG1(fmt, ...)\n#endif\n\n#if DEBUG_LEVEL >= 2\n    #define DEBUG2(fmt, ...) printf("[D2] " fmt "\\n", ##__VA_ARGS__)\n#else\n    #define DEBUG2(fmt, ...)\n#endif\n\n// \u65ad\u8a00\n#define ASSERT(cond) do { \\\n    if (!(cond)) { \\\n        printf("ASSERT: %s, %s:%d\\n", #cond, __FILE__, __LINE__); \\\n        while(1); \\\n    } \\\n} while(0)\n\n// \u4f7f\u7528\u793a\u4f8b\nvoid example(void) {\n    DEBUG1("\u7cfb\u7edf\u542f\u52a8");\n    DEBUG2("\u8be6\u7ec6\u4fe1\u606f: x=%d", 42);\n\n    int *ptr = get_buffer();\n    ASSERT(ptr != NULL);\n}\n'})}),"\n",(0,d.jsx)(e.h3,{id:"gpio-\u8c03\u8bd5",children:"GPIO \u8c03\u8bd5"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"// \u4f7f\u7528 GPIO \u8fdb\u884c\u65f6\u5e8f\u5206\u6790\n#define DEBUG_PIN_HIGH()  GPIOA->BSRR = (1 << 0)\n#define DEBUG_PIN_LOW()   GPIOA->BSRR = (1 << 16)\n#define DEBUG_PIN_PULSE() do { DEBUG_PIN_HIGH(); DEBUG_PIN_LOW(); } while(0)\n\nvoid critical_function(void) {\n    DEBUG_PIN_HIGH();  // \u793a\u6ce2\u5668\u53ef\u6d4b\u91cf\u6267\u884c\u65f6\u95f4\n\n    // \u5173\u952e\u4ee3\u7801\n\n    DEBUG_PIN_LOW();\n}\n"})}),"\n",(0,d.jsx)(e.h2,{id:"\u6700\u4f73\u5b9e\u8df5",children:"\u6700\u4f73\u5b9e\u8df5"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-c",children:"// 1. \u4f7f\u7528\u56fa\u5b9a\u5bbd\u5ea6\u6574\u6570\u7c7b\u578b\n#include <stdint.h>\nuint8_t  byte;\nuint16_t halfword;\nuint32_t word;\n\n// 2. \u5bc4\u5b58\u5668\u8bbf\u95ee\u4f7f\u7528 volatile\nvolatile uint32_t *reg = (volatile uint32_t *)0x40000000;\n\n// 3. \u4f4d\u64cd\u4f5c\u4f7f\u7528\u660e\u786e\u7684\u5b8f\n#define REG_FIELD_MASK  0x0F\n#define REG_FIELD_SHIFT 4\nvalue = (reg & ~(REG_FIELD_MASK << REG_FIELD_SHIFT)) |\n        (new_val << REG_FIELD_SHIFT);\n\n// 4. \u907f\u514d\u52a8\u6001\u5185\u5b58\u5206\u914d\n// \u4f7f\u7528\u9759\u6001\u6570\u7ec4\u6216\u5185\u5b58\u6c60\n\n// 5. \u4e2d\u65ad\u670d\u52a1\u7a0b\u5e8f\u4fdd\u6301\u7b80\u77ed\nvoid ISR_Handler(void) {\n    flag = 1;  // \u8bbe\u7f6e\u6807\u5fd7\uff0c\u4e3b\u5faa\u73af\u5904\u7406\n}\n\n// 6. \u4f7f\u7528\u770b\u95e8\u72d7\u9632\u6b62\u6b7b\u9501\nvoid main_loop(void) {\n    while (1) {\n        process_tasks();\n        watchdog_feed();  // \u5582\u72d7\n    }\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"\u5d4c\u5165\u5f0f C \u7f16\u7a0b\u9700\u8981\u540c\u65f6\u7406\u89e3\u786c\u4ef6\u548c\u8f6f\u4ef6\uff0c\u795d\u4f60\u5b66\u4e60\u987a\u5229\uff01\ud83d\udd27"})]})}function c(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(o,{...n})}):o(n)}}}]);