"use strict";(globalThis.webpackChunkto_lib_github_io=globalThis.webpackChunkto_lib_github_io||[]).push([[9303],{16380:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>u,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"rust/advanced-internals","title":"\u5e95\u5c42\u539f\u7406","description":"\u672c\u6587\u6df1\u5165\u63a2\u8ba8 Rust \u7684\u5e95\u5c42\u539f\u7406\uff0c\u9002\u5408\u60f3\u8981\u6df1\u5165\u7406\u89e3\u8bed\u8a00\u5185\u90e8\u673a\u5236\u7684\u5f00\u53d1\u8005\u3002","source":"@site/docs/rust/advanced-internals.md","sourceDirName":"rust","slug":"/rust/advanced-internals","permalink":"/docs/rust/advanced-internals","draft":false,"unlisted":false,"editUrl":"https://github.com/to-lib/to-lib.github.io/tree/main/docs/rust/advanced-internals.md","tags":[],"version":"current","sidebarPosition":15,"frontMatter":{"sidebar_position":15,"title":"\u5e95\u5c42\u539f\u7406"},"sidebar":"rust","previous":{"title":"\u4e0d\u5b89\u5168 Rust","permalink":"/docs/rust/unsafe-rust"},"next":{"title":"\u5de5\u7a0b\u5316\u5b9e\u8df5","permalink":"/docs/rust/engineering"}}');var r=t(22714),l=t(48885);const i={sidebar_position:15,title:"\u5e95\u5c42\u539f\u7406"},a="\u5e95\u5c42\u539f\u7406",u={},d=[{value:"\u5185\u5b58\u5e03\u5c40",id:"\u5185\u5b58\u5e03\u5c40",level:2},{value:"\u57fa\u672c\u7c7b\u578b\u5e03\u5c40",id:"\u57fa\u672c\u7c7b\u578b\u5e03\u5c40",level:3},{value:"\u7ed3\u6784\u4f53\u5e03\u5c40",id:"\u7ed3\u6784\u4f53\u5e03\u5c40",level:3},{value:"\u679a\u4e3e\u5e03\u5c40",id:"\u679a\u4e3e\u5e03\u5c40",level:3},{value:"\u81ea\u5b9a\u4e49\u667a\u80fd\u6307\u9488",id:"\u81ea\u5b9a\u4e49\u667a\u80fd\u6307\u9488",level:2},{value:"\u5b9e\u73b0 Deref",id:"\u5b9e\u73b0-deref",level:3},{value:"\u5b9e\u73b0 Drop",id:"\u5b9e\u73b0-drop",level:3},{value:"\u5f15\u7528\u8ba1\u6570\u6307\u9488",id:"\u5f15\u7528\u8ba1\u6570\u6307\u9488",level:3},{value:"\u81ea\u5df1\u5b9e\u73b0 Future",id:"\u81ea\u5df1\u5b9e\u73b0-future",level:2},{value:"\u7ec4\u5408 Future",id:"\u7ec4\u5408-future",level:3},{value:"Mini Runtime",id:"mini-runtime",level:2},{value:"FFI",id:"ffi",level:2},{value:"\u8c03\u7528 C \u51fd\u6570",id:"\u8c03\u7528-c-\u51fd\u6570",level:3},{value:"\u66b4\u9732 Rust \u51fd\u6570\u7ed9 C",id:"\u66b4\u9732-rust-\u51fd\u6570\u7ed9-c",level:3},{value:"\u5904\u7406 C \u5b57\u7b26\u4e32",id:"\u5904\u7406-c-\u5b57\u7b26\u4e32",level:3},{value:"cbindgen \u751f\u6210 C \u5934\u6587\u4ef6",id:"cbindgen-\u751f\u6210-c-\u5934\u6587\u4ef6",level:3},{value:"\u603b\u7ed3",id:"\u603b\u7ed3",level:2}];function o(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"\u5e95\u5c42\u539f\u7406",children:"\u5e95\u5c42\u539f\u7406"})}),"\n",(0,r.jsx)(e.p,{children:"\u672c\u6587\u6df1\u5165\u63a2\u8ba8 Rust \u7684\u5e95\u5c42\u539f\u7406\uff0c\u9002\u5408\u60f3\u8981\u6df1\u5165\u7406\u89e3\u8bed\u8a00\u5185\u90e8\u673a\u5236\u7684\u5f00\u53d1\u8005\u3002"}),"\n",(0,r.jsx)(e.h2,{id:"\u5185\u5b58\u5e03\u5c40",children:"\u5185\u5b58\u5e03\u5c40"}),"\n",(0,r.jsx)(e.h3,{id:"\u57fa\u672c\u7c7b\u578b\u5e03\u5c40",children:"\u57fa\u672c\u7c7b\u578b\u5e03\u5c40"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'use std::mem::{size_of, align_of};\n\nfn main() {\n    // \u57fa\u672c\u7c7b\u578b\n    println!("bool: size={}, align={}", size_of::<bool>(), align_of::<bool>());\n    println!("i32: size={}, align={}", size_of::<i32>(), align_of::<i32>());\n    println!("i64: size={}, align={}", size_of::<i64>(), align_of::<i64>());\n\n    // \u6307\u9488\n    println!("&i32: size={}", size_of::<&i32>());  // 8 on 64-bit\n    println!("Box<i32>: size={}", size_of::<Box<i32>>());  // 8\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u7ed3\u6784\u4f53\u5e03\u5c40",children:"\u7ed3\u6784\u4f53\u5e03\u5c40"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"// \u9ed8\u8ba4\u5e03\u5c40\uff08\u53ef\u80fd\u6709\u586b\u5145\uff09\nstruct A { a: u8, b: u32, c: u8 }  // size=12 (\u6709\u586b\u5145)\n\n// \u7d27\u51d1\u5e03\u5c40\n#[repr(C)]\nstruct B { a: u8, b: u32, c: u8 }  // C \u517c\u5bb9\u5e03\u5c40\n\n#[repr(packed)]\nstruct C { a: u8, b: u32, c: u8 }  // size=6 (\u65e0\u586b\u5145)\n\n// \u900f\u660e\u5e03\u5c40\uff08\u5355\u5b57\u6bb5\uff09\n#[repr(transparent)]\nstruct Wrapper(i32);\n"})}),"\n",(0,r.jsx)(e.h3,{id:"\u679a\u4e3e\u5e03\u5c40",children:"\u679a\u4e3e\u5e03\u5c40"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'use std::mem::size_of;\n\nenum Option<T> { None, Some(T) }  // \u5229\u7528\u7a7a\u4f4d\u4f18\u5316\nenum Result<T, E> { Ok(T), Err(E) }\n\nfn main() {\n    // \u7a7a\u4f4d\u4f18\u5316\n    println!("Option<&i32>: {}", size_of::<Option<&i32>>());  // 8\uff0c\u975e 16\n    println!("Option<Box<i32>>: {}", size_of::<Option<Box<i32>>>());  // 8\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u81ea\u5b9a\u4e49\u667a\u80fd\u6307\u9488",children:"\u81ea\u5b9a\u4e49\u667a\u80fd\u6307\u9488"}),"\n",(0,r.jsx)(e.h3,{id:"\u5b9e\u73b0-deref",children:"\u5b9e\u73b0 Deref"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"use std::ops::{Deref, DerefMut};\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> { MyBox(x) }\n}\n\nimpl<T> Deref for MyBox<T> {\n    type Target = T;\n    fn deref(&self) -> &T { &self.0 }\n}\n\nimpl<T> DerefMut for MyBox<T> {\n    fn deref_mut(&mut self) -> &mut T { &mut self.0 }\n}\n\nfn main() {\n    let x = MyBox::new(5);\n    assert_eq!(*x, 5);\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"\u5b9e\u73b0-drop",children:"\u5b9e\u73b0 Drop"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'struct CustomSmartPointer { data: String }\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&mut self) {\n        println!("Dropping with data: {}", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer { data: String::from("hello") };\n    drop(c);  // \u663e\u5f0f\u8c03\u7528\n    println!("CustomSmartPointer dropped");\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u5f15\u7528\u8ba1\u6570\u6307\u9488",children:"\u5f15\u7528\u8ba1\u6570\u6307\u9488"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"use std::cell::Cell;\nuse std::ptr::NonNull;\n\nstruct MyRc<T> {\n    ptr: NonNull<RcBox<T>>,\n}\n\nstruct RcBox<T> {\n    value: T,\n    ref_count: Cell<usize>,\n}\n\nimpl<T> MyRc<T> {\n    fn new(value: T) -> Self {\n        let boxed = Box::new(RcBox {\n            value,\n            ref_count: Cell::new(1),\n        });\n        MyRc { ptr: NonNull::new(Box::into_raw(boxed)).unwrap() }\n    }\n\n    fn strong_count(&self) -> usize {\n        unsafe { self.ptr.as_ref().ref_count.get() }\n    }\n}\n\nimpl<T> Clone for MyRc<T> {\n    fn clone(&self) -> Self {\n        unsafe {\n            let count = self.ptr.as_ref().ref_count.get();\n            self.ptr.as_ref().ref_count.set(count + 1);\n        }\n        MyRc { ptr: self.ptr }\n    }\n}\n\nimpl<T> Drop for MyRc<T> {\n    fn drop(&mut self) {\n        unsafe {\n            let count = self.ptr.as_ref().ref_count.get();\n            self.ptr.as_ref().ref_count.set(count - 1);\n            if count == 1 {\n                drop(Box::from_raw(self.ptr.as_ptr()));\n            }\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"\u81ea\u5df1\u5b9e\u73b0-future",children:"\u81ea\u5df1\u5b9e\u73b0 Future"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'use std::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\n// \u7b80\u5355\u7684\u5ef6\u8fdf Future\nstruct Delay {\n    when: std::time::Instant,\n}\n\nimpl Future for Delay {\n    type Output = ();\n\n    fn poll(self: Pin<&mut Self>, cx: &mut Context<\'_>) -> Poll<Self::Output> {\n        if std::time::Instant::now() >= self.when {\n            Poll::Ready(())\n        } else {\n            // \u6ce8\u518c\u5524\u9192\u5668\n            let waker = cx.waker().clone();\n            let when = self.when;\n            std::thread::spawn(move || {\n                std::thread::sleep(when - std::time::Instant::now());\n                waker.wake();\n            });\n            Poll::Pending\n        }\n    }\n}\n\nasync fn example() {\n    let delay = Delay { when: std::time::Instant::now() + std::time::Duration::from_secs(1) };\n    delay.await;\n    println!("Delay complete!");\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u7ec4\u5408-future",children:"\u7ec4\u5408 Future"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"use std::future::Future;\nuse std::pin::Pin;\nuse std::task::{Context, Poll};\n\n// Join \u4e24\u4e2a Future\nstruct Join<A, B> {\n    a: Option<A>,\n    b: Option<B>,\n    a_result: Option<A::Output>,\n    b_result: Option<B::Output>,\n}\n\nimpl<A, B> Future for Join<A, B>\nwhere\n    A: Future + Unpin,\n    B: Future + Unpin,\n{\n    type Output = (A::Output, B::Output);\n\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        if let Some(a) = self.a.as_mut() {\n            if let Poll::Ready(result) = Pin::new(a).poll(cx) {\n                self.a_result = Some(result);\n                self.a = None;\n            }\n        }\n        if let Some(b) = self.b.as_mut() {\n            if let Poll::Ready(result) = Pin::new(b).poll(cx) {\n                self.b_result = Some(result);\n                self.b = None;\n            }\n        }\n        if self.a.is_none() && self.b.is_none() {\n            Poll::Ready((self.a_result.take().unwrap(), self.b_result.take().unwrap()))\n        } else {\n            Poll::Pending\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"mini-runtime",children:"Mini Runtime"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:"use std::collections::VecDeque;\nuse std::future::Future;\nuse std::pin::Pin;\nuse std::sync::{Arc, Mutex};\nuse std::task::{Context, Poll, RawWaker, RawWakerVTable, Waker};\n\ntype Task = Pin<Box<dyn Future<Output = ()> + Send>>;\n\nstruct MiniRuntime {\n    tasks: Mutex<VecDeque<Task>>,\n}\n\nimpl MiniRuntime {\n    fn new() -> Arc<Self> {\n        Arc::new(MiniRuntime { tasks: Mutex::new(VecDeque::new()) })\n    }\n\n    fn spawn(&self, future: impl Future<Output = ()> + Send + 'static) {\n        self.tasks.lock().unwrap().push_back(Box::pin(future));\n    }\n\n    fn run(&self) {\n        loop {\n            let task = { self.tasks.lock().unwrap().pop_front() };\n            match task {\n                Some(mut task) => {\n                    let waker = dummy_waker();\n                    let mut cx = Context::from_waker(&waker);\n                    match task.as_mut().poll(&mut cx) {\n                        Poll::Ready(()) => {}\n                        Poll::Pending => {\n                            self.tasks.lock().unwrap().push_back(task);\n                        }\n                    }\n                }\n                None => break,\n            }\n        }\n    }\n}\n\nfn dummy_waker() -> Waker {\n    fn clone(_: *const ()) -> RawWaker { RawWaker::new(std::ptr::null(), &VTABLE) }\n    fn wake(_: *const ()) {}\n    fn wake_by_ref(_: *const ()) {}\n    fn drop(_: *const ()) {}\n\n    static VTABLE: RawWakerVTable = RawWakerVTable::new(clone, wake, wake_by_ref, drop);\n    unsafe { Waker::from_raw(RawWaker::new(std::ptr::null(), &VTABLE)) }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"ffi",children:"FFI"}),"\n",(0,r.jsx)(e.h3,{id:"\u8c03\u7528-c-\u51fd\u6570",children:"\u8c03\u7528 C \u51fd\u6570"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// \u94fe\u63a5 C \u5e93\n#[link(name = "c")]\nextern "C" {\n    fn abs(input: i32) -> i32;\n    fn strlen(s: *const i8) -> usize;\n}\n\nfn main() {\n    unsafe {\n        println!("abs(-5) = {}", abs(-5));\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u66b4\u9732-rust-\u51fd\u6570\u7ed9-c",children:"\u66b4\u9732 Rust \u51fd\u6570\u7ed9 C"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'#[no_mangle]\npub extern "C" fn rust_add(a: i32, b: i32) -> i32 {\n    a + b\n}\n\n#[no_mangle]\npub extern "C" fn rust_string_len(s: *const std::ffi::c_char) -> usize {\n    if s.is_null() { return 0; }\n    unsafe { std::ffi::CStr::from_ptr(s).to_bytes().len() }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"\u5904\u7406-c-\u5b57\u7b26\u4e32",children:"\u5904\u7406 C \u5b57\u7b26\u4e32"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'use std::ffi::{CStr, CString};\nuse std::os::raw::c_char;\n\nfn rust_string_to_c(s: &str) -> *mut c_char {\n    CString::new(s).unwrap().into_raw()\n}\n\nfn c_string_to_rust(s: *const c_char) -> String {\n    unsafe { CStr::from_ptr(s).to_string_lossy().into_owned() }\n}\n\n#[no_mangle]\npub extern "C" fn free_rust_string(s: *mut c_char) {\n    if !s.is_null() {\n        unsafe { drop(CString::from_raw(s)); }\n    }\n}\n'})}),"\n",(0,r.jsx)(e.h3,{id:"cbindgen-\u751f\u6210-c-\u5934\u6587\u4ef6",children:"cbindgen \u751f\u6210 C \u5934\u6587\u4ef6"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-toml",children:'# Cargo.toml\n[lib]\ncrate-type = ["cdylib"]\n\n[build-dependencies]\ncbindgen = "0.26"\n'})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-rust",children:'// build.rs\nfn main() {\n    let crate_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();\n    cbindgen::generate(&crate_dir)\n        .expect("Unable to generate bindings")\n        .write_to_file("target/include/mylib.h");\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"\u603b\u7ed3",children:"\u603b\u7ed3"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"\u4e3b\u9898"}),(0,r.jsx)(e.th,{children:"\u5173\u952e\u70b9"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"\u5185\u5b58\u5e03\u5c40"}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.code,{children:"#repr(C)"}),", ",(0,r.jsx)(e.code,{children:"#repr(packed)"}),", \u7a7a\u4f4d\u4f18\u5316"]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"\u667a\u80fd\u6307\u9488"}),(0,r.jsxs)(e.td,{children:["\u5b9e\u73b0 ",(0,r.jsx)(e.code,{children:"Deref"}),", ",(0,r.jsx)(e.code,{children:"Drop"})]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Future"}),(0,r.jsxs)(e.td,{children:["\u5b9e\u73b0 ",(0,r.jsx)(e.code,{children:"poll"}),", \u8fd4\u56de ",(0,r.jsx)(e.code,{children:"Poll::Ready/Pending"})]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Runtime"}),(0,r.jsx)(e.td,{children:"\u4efb\u52a1\u961f\u5217 + Waker \u673a\u5236"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"FFI"}),(0,r.jsxs)(e.td,{children:[(0,r.jsx)(e.code,{children:'extern "C"'}),", ",(0,r.jsx)(e.code,{children:"#[no_mangle]"}),", ",(0,r.jsx)(e.code,{children:"CString"})]})]})]})]}),"\n",(0,r.jsx)(e.p,{children:"\u6df1\u5165\u7406\u89e3\u8fd9\u4e9b\u5e95\u5c42\u539f\u7406\uff0c\u80fd\u8ba9\u4f60\u66f4\u597d\u5730\u9a7e\u9a6d Rust\uff01"})]})}function c(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(o,{...n})}):o(n)}},48885:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>a});var s=t(99378);const r={},l=s.createContext(r);function i(n){const e=s.useContext(l);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:i(n.components),s.createElement(l.Provider,{value:e},n.children)}}}]);