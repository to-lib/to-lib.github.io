---
sidebar_position: 25
title: 系统设计面试题
slug: /interview/system-design-interview-questions
---

# 🏗️ 系统设计面试题

> [!TIP]
> 系统设计面试考察的是你在面对复杂、大规模系统时的架构能力。重点在于**权衡(Trade-off)**、**扩展性**和**可行性**。

## 🎯 基础概念

### 1. 什么是 CAP 定理？

**答案**:

CAP 定理指出，在分布式系统中，无法同时满足以下三点，最多只能满足其中两点：

- **Consistency (一致性)**: 所有节点在同一时间读到相同的数据。
- **Availability (可用性)**: 每次请求都能得到响应（不保证数据最新）。
- **Partition Tolerance (分区容错性)**: 系统在网络分区（节点间通信失败）时仍能继续运行。

**权衡**:

- **CP (一致性 + 分区容错)**: 牺牲可用性。如 HBase, Redis (默认)。适用于对数据一致性要求高的场景（如金融）。
- **AP (可用性 + 分区容错)**: 牺牲一致性（保证最终一致性）。如 Cassandra, DynamoDB。适用于追求高可用的场景（如社交网络）。

### 2. 负载均衡有哪些算法？

**答案**:

1.  **轮询 (Round Robin)**: 依次分配请求。
2.  **加权轮询 (Weighted Round Robin)**: 根据服务器性能加权。
3.  **最少连接 (Least Connections)**: 分配给当前连接数最少的服务器。
4.  **IP Hash**: 根据 IP 哈希值分配，确保同一 IP 访问同一服务器（会话保持）。
5.  **一致性哈希 (Consistent Hashing)**: 减少节点增减时的缓存抖动，常用于分布式缓存。

### 3. 常见的缓存策略有哪些？

**答案**:

- **Cache Aside (旁路缓存)**: 应用先读缓存，不命中读库并回填；写时先更新库，再删缓存。最常用。
- **Read/Write Through**: 应用只与缓存交互，缓存负责与数据库同步。
- **Write Behind (异步写回)**: 应用只写缓存，缓存异步批量同步数据库。性能最高，但有丢失数据风险。

---

## 🏛️ 经典设计题

### 4. 设计一个 URL 短链生成器 (TinyURL)

**核心要点**:

1.  **API 设计**:
    - `createShortURL(originalURL) -> shortURL`
    - `getOriginalURL(shortURL) -> originalURL` (HTTP 301/302 重定向)
2.  **唯一 ID 生成**:
    - **数据库自增 ID**: 简单，但需考虑分库分表。
    - **分布式 ID (Snowflake)**: 高性能，有序。
    - **Redis 自增**: 性能极高。
3.  **Base62 编码**: 将 ID 转为 [a-z, A-Z, 0-9] 字符串 (62 进制)，缩短长度。
4.  **存储**:
    - K-V 数据库 (Redis/DynamoDB) 适合，读写快。
    - RDBMS (MySQL) 加上索引也可以支撑很大规模。

### 5. 设计 Twitter (Feeds 流系统)

**核心模式**:

1.  **Pull 模型 (拉模式)**:
    - 用户查看 Feeds 时，查询关注列表，拉取他们最新的推文进行聚合排序。
    - 优点：实现简单，节约存储。
    - 缺点：读取延迟高。
2.  **Push 模型 (推模式/写扩散)**:
    - 大 V 发推文时，直接写入所有粉丝的 Feeds 列表 (Inbox)。
    - 优点：读取快（O(1)）。
    - 缺点：写入成本大，大 V 粉丝多时会有"惊群效应"。
3.  **混合模式**:
    - 普通用户使用 Push。
    - 大 V (粉丝 > 100w) 使用 Pull。

### 6. 设计秒杀系统

**核心挑战**: 高并发、库存超卖、系统稳定性

**架构设计**:

```
用户请求 → CDN/Nginx → 网关限流 → 业务验证 → Redis 预减库存 → MQ → 订单服务
```

**关键技术点**:

1. **多级限流**:

   - 前端：按钮禁止重复点击
   - 网关：令牌桶/漏桶限流
   - 应用层：用户级限流

2. **库存预热**:
   - 活动前将库存加载到 Redis
   - Lua 脚本保证原子性扣减

```lua
local stock = redis.call('GET', KEYS[1])
if tonumber(stock) > 0 then
    redis.call('DECR', KEYS[1])
    return 1  -- 扣减成功
end
return 0  -- 库存不足
```

3. **异步下单**: MQ 削峰填谷
4. **兜底方案**: 超卖后退款、服务降级

### 7. 设计即时通讯系统 (IM)

**核心组件**:

1. **连接层**:

   - 长连接管理 (WebSocket/TCP)
   - 心跳保活、断线重连

2. **消息投递**:

   - 在线：直推
   - 离线：消息存储 + 推送通知

3. **消息存储**:

   ```
   message_id | sender_id | receiver_id | content | timestamp | status
   ```

4. **消息可靠性**:

   - ACK 确认机制
   - 消息去重 (message_id)
   - 已读回执

5. **群聊设计**:
   - 扩散读：消息存一份，读取时扩散
   - 扩散写：写入每个成员的 Inbox

### 8. 设计分布式文件系统

**核心组件**:

1. **Master Node (元数据服务)**:

   - 管理文件元数据 (文件名、大小、块列表)
   - 管理数据节点状态

2. **Data Node (存储服务)**:

   - 存储文件块
   - 定期向 Master 发送心跳和块报告

3. **文件读写流程**:

   - **写入**: Client → Master (获取块位置) → Data Node (写数据 + 副本)
   - **读取**: Client → Master (获取块位置) → Data Node (读数据)

4. **可靠性保证**:
   - 多副本存储 (通常 3 副本)
   - 机架感知：副本分布在不同机架
   - 定期校验和修复

---

## 💾 数据库与存储

### 9. SQL vs NoSQL 如何选择？

**答案**:

- **SQL (MySQL, PostgreSQL)**:
  - 结构化数据，关系复杂。
  - 需要 ACID 事务支持。
  - 数据量适中，或者可以通过分库分表解决。
- **NoSQL (MongoDB, Redis, Cassandra)**:
  - 非结构化/半结构化数据。
  - 海量数据，高吞吐量写入。
  - 灵活性高，Schema-less。
  - 对一致性要求不苛刻 (最终一致性)。

### 10. 数据复制与分片

- **主从复制 (Replication)**: 提高读性能，数据备份。
- **分片 (Sharding)**: 水平切分，解决单机存储和写入瓶颈。
  - 垂直分片：按业务/列拆分。
  - 水平分片：按 ID 范围/哈希拆分。

### 11. 如何设计分库分表?

**分片键选择**:

- 选择高区分度、查询频繁的字段
- 如：用户 ID、订单 ID

**分片策略**:
| 策略 | 优点 | 缺点 |
|-----|------|------|
| 范围分片 | 范围查询高效 | 数据倾斜 |
| 哈希分片 | 数据均匀 | 范围查询需聚合 |
| 一致性哈希 | 扩容影响小 | 实现复杂 |

---

## 🔒 认证与安全

### 12. Session vs JWT (JSON Web Token)

**答案**:

- **Session**:
  - 服务端存储状态。
  - 客户端存 SessionID (Cookie)。
  - 优点：安全，服务端可控（可强制下线）。
  - 缺点：分布式环境需要共享 Session (Redis)。
- **JWT**:
  - 无状态，信息自包含在 Token 中。
  - 优点：扩展性好，无需查库。
  - 缺点：Token 一旦签发无法撤销（需配合黑名单），体积较大。

---

## 📊 容量估算

### 13. 如何进行容量估算？

**常用数据**:

- 1 天 = 86,400 秒 ≈ 100,000 秒
- 1M 用户，每人每天 10 次请求 = 10M 请求/天 ≈ 100 QPS

**案例：设计 Twitter**

假设：

- DAU: 2 亿
- 每人每天发 2 条推文，读 100 条
- 推文大小：500 bytes

**计算**:

- 写 QPS: 2 亿 × 2 / 100,000 = 4,000 QPS
- 读 QPS: 2 亿 × 100 / 100,000 = 200,000 QPS
- 日存储: 2 亿 × 2 × 500 bytes = 200 GB/天

---

## 💡 面试技巧

1. **Clarify Constraints**: 即使是开放性问题，也要先问清楚 QPS、数据量、延迟要求等约束条件。
2. **High Level Design**: 先画出整体架构图，再深入细节。
3. **Address Bottlenecks**: 主动识别单点故障和性能瓶颈，并提出解决方案。
4. **Trade-offs**: 说明每个设计决策的优缺点，展示权衡能力。
5. **Iterate**: 先给出简单方案，再逐步优化。
