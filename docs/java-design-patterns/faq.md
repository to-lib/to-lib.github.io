---
sidebar_position: 9
title: 常见问题
description: 设计模式学习与实践常见问题解答
---

# 常见问题 (FAQ)

本文档整理了学习和应用设计模式过程中的常见问题与解答。

## 基础概念问题

### Q1: 什么是设计模式？为什么要学习设计模式？

**答**：设计模式是针对软件开发中反复出现问题的**可复用解决方案**。学习设计模式的好处：

- ✅ **提高代码质量**：遵循最佳实践，写出更清晰、更易维护的代码
- ✅ **提升沟通效率**：与团队成员使用统一的设计语言
- ✅ **加速开发**：直接应用成熟的解决方案
- ✅ **面试加分**：设计模式是技术面试的高频考点

---

### Q2: 23 种设计模式都需要掌握吗？

**答**：不需要。建议分优先级学习：

| 优先级       | 模式                                                                          | 说明             |
| ------------ | ----------------------------------------------------------------------------- | ---------------- |
| **必须掌握** | Singleton, Factory Method, Strategy, Observer, Decorator                      | 日常开发高频使用 |
| **建议掌握** | Builder, Adapter, Proxy, Template Method, Command, State                      | 常见场景         |
| **了解即可** | Abstract Factory, Prototype, Bridge, Composite, Flyweight, Facade, 其他行为型 | 特定场景使用     |

---

### Q3: 设计模式和设计原则有什么区别？

**答**：

- **设计原则**（SOLID）：抽象的指导思想，如单一职责、开闭原则
- **设计模式**：具体的解决方案，是设计原则的实践应用

设计模式通常遵循一个或多个设计原则。例如：

- 策略模式遵循开闭原则（新增策略不修改原代码）
- 单一职责原则指导我们何时拆分类

---

## JDK 1.8 相关问题

### Q4: 为什么本文档基于 JDK 1.8？

**答**：选择 JDK 1.8 的原因：

1. **企业主流**：JDK 8 仍是企业级应用最广泛使用的版本
2. **特性丰富**：Lambda、Stream API、函数式接口等特性让代码更简洁
3. **稳定可靠**：自 2014 年发布，经过多年验证
4. **向后兼容**：代码可在更高版本 JDK 上运行

---

### Q5: 代码能在更高版本 JDK 上运行吗？

**答**：是的。本文档代码完全兼容 JDK 9-21+。只需将编译目标设置为 1.8：

```xml
<!-- Maven -->
<properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
</properties>
```

---

### Q6: Lambda 表达式在设计模式中有什么应用？

**答**：Lambda 可以简化策略模式、命令模式等的实现：

```java
// 传统策略模式：需要创建多个策略类
PaymentStrategy paypal = new PayPalPayment();
cart.checkout(paypal);

// 使用 Lambda 简化（策略接口只有一个抽象方法时）
cart.checkout(amount -> System.out.println("支付: " + amount));
```

---

## 模式选择问题

### Q7: 如何选择合适的设计模式？

**答**：根据问题类型选择：

| 需求场景             | 推荐模式                          |
| -------------------- | --------------------------------- |
| 创建全局唯一对象     | Singleton                         |
| 根据条件创建不同对象 | Factory Method / Abstract Factory |
| 构建复杂对象         | Builder                           |
| 动态添加功能         | Decorator                         |
| 接口不兼容           | Adapter                           |
| 控制对象访问         | Proxy                             |
| 一对多事件通知       | Observer                          |
| 可切换的算法         | Strategy                          |
| 对象状态改变行为     | State                             |

详见 [模式选择指南](selection-guide)。

---

### Q8: 工厂模式和抽象工厂模式的区别？

**答**：

| 对比项       | 工厂方法             | 抽象工厂                 |
| ------------ | -------------------- | ------------------------ |
| **产品数量** | 创建单一产品         | 创建产品族               |
| **扩展方式** | 新增工厂子类         | 新增工厂和多个产品类     |
| **复杂度**   | 中等                 | 较高                     |
| **适用场景** | 产品类型单一但会扩展 | 多个相关产品需要一起创建 |

---

### Q9: 策略模式和状态模式的区别？

**答**：两者结构相似，但意图不同：

| 对比项       | 策略模式       | 状态模式         |
| ------------ | -------------- | ---------------- |
| **切换触发** | 客户端主动设置 | 对象内部自动切换 |
| **意图**     | 选择不同算法   | 根据状态改变行为 |
| **示例**     | 选择支付方式   | 订单状态流转     |

---

### Q10: 装饰器模式和代理模式的区别？

**答**：

| 对比项       | 装饰器模式         | 代理模式             |
| ------------ | ------------------ | -------------------- |
| **目的**     | 增强功能           | 控制访问             |
| **实例创建** | 客户端创建装饰器链 | 代理内部创建真实对象 |
| **透明度**   | 完全透明           | 可能对客户端透明     |
| **典型场景** | Java IO 流         | Spring AOP           |

---

## 实践应用问题

### Q11: 单例模式在多线程环境下如何保证安全？

**答**：推荐两种方式：

1. **静态内部类**（推荐）

```java
public class Singleton {
    private static class Holder {
        static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

2. **枚举单例**（最安全）

```java
public enum Singleton {
    INSTANCE;
    public void doSomething() { }
}
```

---

### Q12: 设计模式会影响性能吗？

**答**：大多数设计模式对性能影响可忽略。但需注意：

| 模式             | 潜在影响             | 优化建议                 |
| ---------------- | -------------------- | ------------------------ |
| 单例（同步方法） | 每次调用加锁         | 使用双重检查或静态内部类 |
| 装饰器           | 多层包装增加调用开销 | 避免过度嵌套             |
| 观察者           | 大量观察者时通知耗时 | 考虑异步通知             |
| 代理（反射）     | 反射调用较慢         | 考虑 CGLib 字节码增强    |

---

### Q13: 如何在 Spring 中应用设计模式？

**答**：Spring 框架大量使用设计模式：

| Spring 组件         | 使用的模式      |
| ------------------- | --------------- |
| Bean 默认作用域     | Singleton       |
| BeanFactory         | Factory         |
| ApplicationContext  | Facade          |
| AOP                 | Proxy           |
| JdbcTemplate        | Template Method |
| ApplicationEvent    | Observer        |
| @Autowired + 多实现 | Strategy        |

---

### Q14: 设计模式是否过度设计？

**答**：过度设计确实存在，判断标准：

**不需要设计模式的情况**：

- 简单的 CRUD 操作
- 确定不会变化的逻辑
- 原型或一次性项目

**需要设计模式的情况**：

- 需求频繁变化
- 需要支持多种实现
- 代码需要良好的扩展性

> 💡 **建议**：遵循 YAGNI（You Aren't Gonna Need It）原则，先实现再重构。

---

## 学习方法问题

### Q15: 如何有效学习设计模式？

**答**：推荐学习路径：

1. **理解概念**：阅读模式定义和 UML 图
2. **看代码**：分析示例代码实现
3. **写代码**：完成 [练习题](exercises)
4. **找应用**：在开源项目中寻找模式应用（如 JDK 源码）
5. **项目实践**：在实际项目中应用

---

### Q16: 推荐的学习资源？

**答**：

| 类型 | 推荐资源                                                                        |
| ---- | ------------------------------------------------------------------------------- |
| 书籍 | 《Head First 设计模式》（入门）、《设计模式：可复用面向对象软件的基础》（经典） |
| 在线 | Refactoring.Guru、java-design-patterns.com                                      |
| 源码 | JDK 源码、Spring Framework                                                      |

---

### Q17: 如何记忆这么多设计模式？

**答**：

1. **按分类记忆**：创建型（怎么创建）、结构型（怎么组合）、行为型（怎么交互）
2. **联想记忆**：将模式与实际场景关联（如观察者 = 微信公众号订阅）
3. **对比记忆**：类似模式放在一起比较（如策略 vs 状态）
4. **动手实践**：写代码比死记硬背有效

---

## 其他问题

### Q18: 设计模式过时了吗？

**答**：没有过时。虽然 23 种经典模式诞生于 1994 年，但核心思想不变。现代语言（如 Java 8+）可能简化了某些模式的实现，但模式本身的价值依然存在。

---

### Q19: 函数式编程会取代设计模式吗？

**答**：不会完全取代，但会简化某些模式：

| 模式            | 函数式替代               |
| --------------- | ------------------------ |
| Strategy        | Lambda 表达式 / 函数引用 |
| Command         | Lambda + Runnable        |
| Template Method | 高阶函数                 |
| Observer        | Reactive Streams         |

---

### Q20: 还有其他设计模式吗？

**答**：是的，除了 GoF 23 种经典模式，还有：

- **企业应用模式**：DAO、DTO、Repository
- **并发模式**：生产者-消费者、读写锁
- **架构模式**：MVC、MVVM、微服务模式
- **现代模式**：依赖注入、事件溯源

---

如有其他问题，欢迎查阅各模式的详细文档或参考 [面试题集](interview-questions)！
